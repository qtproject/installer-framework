// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: eve_public/app/platform.proto

#ifndef PROTOBUF_INCLUDED_eve_5fpublic_2fapp_2fplatform_2eproto
#define PROTOBUF_INCLUDED_eve_5fpublic_2fapp_2fplatform_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_eve_5fpublic_2fapp_2fplatform_2eproto 

namespace protobuf_eve_5fpublic_2fapp_2fplatform_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[15];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_eve_5fpublic_2fapp_2fplatform_2eproto
namespace eve_public {
namespace app {
namespace platform {
class Information;
class InformationDefaultTypeInternal;
extern InformationDefaultTypeInternal _Information_default_instance_;
class Machine;
class MachineDefaultTypeInternal;
extern MachineDefaultTypeInternal _Machine_default_instance_;
class Machine_CPU;
class Machine_CPUDefaultTypeInternal;
extern Machine_CPUDefaultTypeInternal _Machine_CPU_default_instance_;
class Machine_GPU;
class Machine_GPUDefaultTypeInternal;
extern Machine_GPUDefaultTypeInternal _Machine_GPU_default_instance_;
class Machine_GPU_Driver;
class Machine_GPU_DriverDefaultTypeInternal;
extern Machine_GPU_DriverDefaultTypeInternal _Machine_GPU_Driver_default_instance_;
class Machine_HardDrive;
class Machine_HardDriveDefaultTypeInternal;
extern Machine_HardDriveDefaultTypeInternal _Machine_HardDrive_default_instance_;
class Machine_Monitor;
class Machine_MonitorDefaultTypeInternal;
extern Machine_MonitorDefaultTypeInternal _Machine_Monitor_default_instance_;
class Machine_NetworkAdapter;
class Machine_NetworkAdapterDefaultTypeInternal;
extern Machine_NetworkAdapterDefaultTypeInternal _Machine_NetworkAdapter_default_instance_;
class Machine_VM;
class Machine_VMDefaultTypeInternal;
extern Machine_VMDefaultTypeInternal _Machine_VM_default_instance_;
class OS;
class OSDefaultTypeInternal;
extern OSDefaultTypeInternal _OS_default_instance_;
class OS_GraphicsAPIs;
class OS_GraphicsAPIsDefaultTypeInternal;
extern OS_GraphicsAPIsDefaultTypeInternal _OS_GraphicsAPIs_default_instance_;
class OS_StreamingService;
class OS_StreamingServiceDefaultTypeInternal;
extern OS_StreamingServiceDefaultTypeInternal _OS_StreamingService_default_instance_;
class OS_Wine;
class OS_WineDefaultTypeInternal;
extern OS_WineDefaultTypeInternal _OS_Wine_default_instance_;
class Process;
class ProcessDefaultTypeInternal;
extern ProcessDefaultTypeInternal _Process_default_instance_;
class SemanticVersion;
class SemanticVersionDefaultTypeInternal;
extern SemanticVersionDefaultTypeInternal _SemanticVersion_default_instance_;
}  // namespace platform
}  // namespace app
}  // namespace eve_public
namespace google {
namespace protobuf {
template<> ::eve_public::app::platform::Information* Arena::CreateMaybeMessage<::eve_public::app::platform::Information>(Arena*);
template<> ::eve_public::app::platform::Machine* Arena::CreateMaybeMessage<::eve_public::app::platform::Machine>(Arena*);
template<> ::eve_public::app::platform::Machine_CPU* Arena::CreateMaybeMessage<::eve_public::app::platform::Machine_CPU>(Arena*);
template<> ::eve_public::app::platform::Machine_GPU* Arena::CreateMaybeMessage<::eve_public::app::platform::Machine_GPU>(Arena*);
template<> ::eve_public::app::platform::Machine_GPU_Driver* Arena::CreateMaybeMessage<::eve_public::app::platform::Machine_GPU_Driver>(Arena*);
template<> ::eve_public::app::platform::Machine_HardDrive* Arena::CreateMaybeMessage<::eve_public::app::platform::Machine_HardDrive>(Arena*);
template<> ::eve_public::app::platform::Machine_Monitor* Arena::CreateMaybeMessage<::eve_public::app::platform::Machine_Monitor>(Arena*);
template<> ::eve_public::app::platform::Machine_NetworkAdapter* Arena::CreateMaybeMessage<::eve_public::app::platform::Machine_NetworkAdapter>(Arena*);
template<> ::eve_public::app::platform::Machine_VM* Arena::CreateMaybeMessage<::eve_public::app::platform::Machine_VM>(Arena*);
template<> ::eve_public::app::platform::OS* Arena::CreateMaybeMessage<::eve_public::app::platform::OS>(Arena*);
template<> ::eve_public::app::platform::OS_GraphicsAPIs* Arena::CreateMaybeMessage<::eve_public::app::platform::OS_GraphicsAPIs>(Arena*);
template<> ::eve_public::app::platform::OS_StreamingService* Arena::CreateMaybeMessage<::eve_public::app::platform::OS_StreamingService>(Arena*);
template<> ::eve_public::app::platform::OS_Wine* Arena::CreateMaybeMessage<::eve_public::app::platform::OS_Wine>(Arena*);
template<> ::eve_public::app::platform::Process* Arena::CreateMaybeMessage<::eve_public::app::platform::Process>(Arena*);
template<> ::eve_public::app::platform::SemanticVersion* Arena::CreateMaybeMessage<::eve_public::app::platform::SemanticVersion>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace eve_public {
namespace app {
namespace platform {

enum OS_StreamingService_Provider {
  OS_StreamingService_Provider_PROVIDER_UNSPECIFIED = 0,
  OS_StreamingService_Provider_PROVIDER_UNKNOWN = 1,
  OS_StreamingService_Provider_PROVIDER_INTEL = 2,
  OS_StreamingService_Provider_OS_StreamingService_Provider_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  OS_StreamingService_Provider_OS_StreamingService_Provider_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool OS_StreamingService_Provider_IsValid(int value);
const OS_StreamingService_Provider OS_StreamingService_Provider_Provider_MIN = OS_StreamingService_Provider_PROVIDER_UNSPECIFIED;
const OS_StreamingService_Provider OS_StreamingService_Provider_Provider_MAX = OS_StreamingService_Provider_PROVIDER_INTEL;
const int OS_StreamingService_Provider_Provider_ARRAYSIZE = OS_StreamingService_Provider_Provider_MAX + 1;

const ::google::protobuf::EnumDescriptor* OS_StreamingService_Provider_descriptor();
inline const ::std::string& OS_StreamingService_Provider_Name(OS_StreamingService_Provider value) {
  return ::google::protobuf::internal::NameOfEnum(
    OS_StreamingService_Provider_descriptor(), value);
}
inline bool OS_StreamingService_Provider_Parse(
    const ::std::string& name, OS_StreamingService_Provider* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OS_StreamingService_Provider>(
    OS_StreamingService_Provider_descriptor(), name, value);
}
enum OS_Kind {
  OS_Kind_KIND_UNSPECIFIED = 0,
  OS_Kind_KIND_WINDOWS = 1,
  OS_Kind_KIND_MACOS = 2,
  OS_Kind_KIND_WINE = 3,
  OS_Kind_OS_Kind_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  OS_Kind_OS_Kind_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool OS_Kind_IsValid(int value);
const OS_Kind OS_Kind_Kind_MIN = OS_Kind_KIND_UNSPECIFIED;
const OS_Kind OS_Kind_Kind_MAX = OS_Kind_KIND_WINE;
const int OS_Kind_Kind_ARRAYSIZE = OS_Kind_Kind_MAX + 1;

const ::google::protobuf::EnumDescriptor* OS_Kind_descriptor();
inline const ::std::string& OS_Kind_Name(OS_Kind value) {
  return ::google::protobuf::internal::NameOfEnum(
    OS_Kind_descriptor(), value);
}
inline bool OS_Kind_Parse(
    const ::std::string& name, OS_Kind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OS_Kind>(
    OS_Kind_descriptor(), name, value);
}
enum Machine_CPU_Architecture {
  Machine_CPU_Architecture_ARCHITECTURE_UNSPECIFIED = 0,
  Machine_CPU_Architecture_ARCHITECTURE_X86 = 1,
  Machine_CPU_Architecture_ARCHITECTURE_X86_64 = 2,
  Machine_CPU_Architecture_ARCHITECTURE_ARM = 3,
  Machine_CPU_Architecture_ARCHITECTURE_ARM64 = 4,
  Machine_CPU_Architecture_Machine_CPU_Architecture_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Machine_CPU_Architecture_Machine_CPU_Architecture_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Machine_CPU_Architecture_IsValid(int value);
const Machine_CPU_Architecture Machine_CPU_Architecture_Architecture_MIN = Machine_CPU_Architecture_ARCHITECTURE_UNSPECIFIED;
const Machine_CPU_Architecture Machine_CPU_Architecture_Architecture_MAX = Machine_CPU_Architecture_ARCHITECTURE_ARM64;
const int Machine_CPU_Architecture_Architecture_ARRAYSIZE = Machine_CPU_Architecture_Architecture_MAX + 1;

const ::google::protobuf::EnumDescriptor* Machine_CPU_Architecture_descriptor();
inline const ::std::string& Machine_CPU_Architecture_Name(Machine_CPU_Architecture value) {
  return ::google::protobuf::internal::NameOfEnum(
    Machine_CPU_Architecture_descriptor(), value);
}
inline bool Machine_CPU_Architecture_Parse(
    const ::std::string& name, Machine_CPU_Architecture* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Machine_CPU_Architecture>(
    Machine_CPU_Architecture_descriptor(), name, value);
}
enum Machine_HardDrive_DriveType {
  Machine_HardDrive_DriveType_DRIVETYPE_UNSPECIFIED = 0,
  Machine_HardDrive_DriveType_DRIVETYPE_SSD = 1,
  Machine_HardDrive_DriveType_DRIVETYPE_HDD = 2,
  Machine_HardDrive_DriveType_Machine_HardDrive_DriveType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Machine_HardDrive_DriveType_Machine_HardDrive_DriveType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Machine_HardDrive_DriveType_IsValid(int value);
const Machine_HardDrive_DriveType Machine_HardDrive_DriveType_DriveType_MIN = Machine_HardDrive_DriveType_DRIVETYPE_UNSPECIFIED;
const Machine_HardDrive_DriveType Machine_HardDrive_DriveType_DriveType_MAX = Machine_HardDrive_DriveType_DRIVETYPE_HDD;
const int Machine_HardDrive_DriveType_DriveType_ARRAYSIZE = Machine_HardDrive_DriveType_DriveType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Machine_HardDrive_DriveType_descriptor();
inline const ::std::string& Machine_HardDrive_DriveType_Name(Machine_HardDrive_DriveType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Machine_HardDrive_DriveType_descriptor(), value);
}
inline bool Machine_HardDrive_DriveType_Parse(
    const ::std::string& name, Machine_HardDrive_DriveType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Machine_HardDrive_DriveType>(
    Machine_HardDrive_DriveType_descriptor(), name, value);
}
enum Machine_BatteryDetection {
  Machine_BatteryDetection_BATTERY_UNSPECIFIED = 0,
  Machine_BatteryDetection_BATTERY_DETECTED = 1,
  Machine_BatteryDetection_BATTERY_NOT_DETECTED = 2,
  Machine_BatteryDetection_Machine_BatteryDetection_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Machine_BatteryDetection_Machine_BatteryDetection_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Machine_BatteryDetection_IsValid(int value);
const Machine_BatteryDetection Machine_BatteryDetection_BatteryDetection_MIN = Machine_BatteryDetection_BATTERY_UNSPECIFIED;
const Machine_BatteryDetection Machine_BatteryDetection_BatteryDetection_MAX = Machine_BatteryDetection_BATTERY_NOT_DETECTED;
const int Machine_BatteryDetection_BatteryDetection_ARRAYSIZE = Machine_BatteryDetection_BatteryDetection_MAX + 1;

const ::google::protobuf::EnumDescriptor* Machine_BatteryDetection_descriptor();
inline const ::std::string& Machine_BatteryDetection_Name(Machine_BatteryDetection value) {
  return ::google::protobuf::internal::NameOfEnum(
    Machine_BatteryDetection_descriptor(), value);
}
inline bool Machine_BatteryDetection_Parse(
    const ::std::string& name, Machine_BatteryDetection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Machine_BatteryDetection>(
    Machine_BatteryDetection_descriptor(), name, value);
}
enum Bitness {
  BITNESS_UNSPECIFIED = 0,
  BITNESS_32 = 1,
  BITNESS_64 = 2,
  Bitness_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Bitness_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Bitness_IsValid(int value);
const Bitness Bitness_MIN = BITNESS_UNSPECIFIED;
const Bitness Bitness_MAX = BITNESS_64;
const int Bitness_ARRAYSIZE = Bitness_MAX + 1;

const ::google::protobuf::EnumDescriptor* Bitness_descriptor();
inline const ::std::string& Bitness_Name(Bitness value) {
  return ::google::protobuf::internal::NameOfEnum(
    Bitness_descriptor(), value);
}
inline bool Bitness_Parse(
    const ::std::string& name, Bitness* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Bitness>(
    Bitness_descriptor(), name, value);
}
// ===================================================================

class SemanticVersion : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_public.app.platform.SemanticVersion) */ {
 public:
  SemanticVersion();
  virtual ~SemanticVersion();

  SemanticVersion(const SemanticVersion& from);

  inline SemanticVersion& operator=(const SemanticVersion& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SemanticVersion(SemanticVersion&& from) noexcept
    : SemanticVersion() {
    *this = ::std::move(from);
  }

  inline SemanticVersion& operator=(SemanticVersion&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SemanticVersion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SemanticVersion* internal_default_instance() {
    return reinterpret_cast<const SemanticVersion*>(
               &_SemanticVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(SemanticVersion* other);
  friend void swap(SemanticVersion& a, SemanticVersion& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SemanticVersion* New() const final {
    return CreateMaybeMessage<SemanticVersion>(NULL);
  }

  SemanticVersion* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SemanticVersion>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SemanticVersion& from);
  void MergeFrom(const SemanticVersion& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SemanticVersion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string prerelease = 4;
  void clear_prerelease();
  static const int kPrereleaseFieldNumber = 4;
  const ::std::string& prerelease() const;
  void set_prerelease(const ::std::string& value);
  #if LANG_CXX11
  void set_prerelease(::std::string&& value);
  #endif
  void set_prerelease(const char* value);
  void set_prerelease(const char* value, size_t size);
  ::std::string* mutable_prerelease();
  ::std::string* release_prerelease();
  void set_allocated_prerelease(::std::string* prerelease);

  // string build = 5;
  void clear_build();
  static const int kBuildFieldNumber = 5;
  const ::std::string& build() const;
  void set_build(const ::std::string& value);
  #if LANG_CXX11
  void set_build(::std::string&& value);
  #endif
  void set_build(const char* value);
  void set_build(const char* value, size_t size);
  ::std::string* mutable_build();
  ::std::string* release_build();
  void set_allocated_build(::std::string* build);

  // uint32 major = 1;
  void clear_major();
  static const int kMajorFieldNumber = 1;
  ::google::protobuf::uint32 major() const;
  void set_major(::google::protobuf::uint32 value);

  // uint32 minor = 2;
  void clear_minor();
  static const int kMinorFieldNumber = 2;
  ::google::protobuf::uint32 minor() const;
  void set_minor(::google::protobuf::uint32 value);

  // uint32 patch = 3;
  void clear_patch();
  static const int kPatchFieldNumber = 3;
  ::google::protobuf::uint32 patch() const;
  void set_patch(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:eve_public.app.platform.SemanticVersion)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr prerelease_;
  ::google::protobuf::internal::ArenaStringPtr build_;
  ::google::protobuf::uint32 major_;
  ::google::protobuf::uint32 minor_;
  ::google::protobuf::uint32 patch_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5fpublic_2fapp_2fplatform_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OS_GraphicsAPIs : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_public.app.platform.OS.GraphicsAPIs) */ {
 public:
  OS_GraphicsAPIs();
  virtual ~OS_GraphicsAPIs();

  OS_GraphicsAPIs(const OS_GraphicsAPIs& from);

  inline OS_GraphicsAPIs& operator=(const OS_GraphicsAPIs& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OS_GraphicsAPIs(OS_GraphicsAPIs&& from) noexcept
    : OS_GraphicsAPIs() {
    *this = ::std::move(from);
  }

  inline OS_GraphicsAPIs& operator=(OS_GraphicsAPIs&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OS_GraphicsAPIs& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OS_GraphicsAPIs* internal_default_instance() {
    return reinterpret_cast<const OS_GraphicsAPIs*>(
               &_OS_GraphicsAPIs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(OS_GraphicsAPIs* other);
  friend void swap(OS_GraphicsAPIs& a, OS_GraphicsAPIs& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OS_GraphicsAPIs* New() const final {
    return CreateMaybeMessage<OS_GraphicsAPIs>(NULL);
  }

  OS_GraphicsAPIs* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OS_GraphicsAPIs>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OS_GraphicsAPIs& from);
  void MergeFrom(const OS_GraphicsAPIs& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OS_GraphicsAPIs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string vulkan_highest_supported_version = 3;
  void clear_vulkan_highest_supported_version();
  static const int kVulkanHighestSupportedVersionFieldNumber = 3;
  const ::std::string& vulkan_highest_supported_version() const;
  void set_vulkan_highest_supported_version(const ::std::string& value);
  #if LANG_CXX11
  void set_vulkan_highest_supported_version(::std::string&& value);
  #endif
  void set_vulkan_highest_supported_version(const char* value);
  void set_vulkan_highest_supported_version(const char* value, size_t size);
  ::std::string* mutable_vulkan_highest_supported_version();
  ::std::string* release_vulkan_highest_supported_version();
  void set_allocated_vulkan_highest_supported_version(::std::string* vulkan_highest_supported_version);

  // string d3d_highest_supported_version = 4;
  void clear_d3d_highest_supported_version();
  static const int kD3DHighestSupportedVersionFieldNumber = 4;
  const ::std::string& d3d_highest_supported_version() const;
  void set_d3d_highest_supported_version(const ::std::string& value);
  #if LANG_CXX11
  void set_d3d_highest_supported_version(::std::string&& value);
  #endif
  void set_d3d_highest_supported_version(const char* value);
  void set_d3d_highest_supported_version(const char* value, size_t size);
  ::std::string* mutable_d3d_highest_supported_version();
  ::std::string* release_d3d_highest_supported_version();
  void set_allocated_d3d_highest_supported_version(::std::string* d3d_highest_supported_version);

  // bool metal_supported = 1;
  void clear_metal_supported();
  static const int kMetalSupportedFieldNumber = 1;
  bool metal_supported() const;
  void set_metal_supported(bool value);

  // bool vulkan_supported = 2;
  void clear_vulkan_supported();
  static const int kVulkanSupportedFieldNumber = 2;
  bool vulkan_supported() const;
  void set_vulkan_supported(bool value);

  // @@protoc_insertion_point(class_scope:eve_public.app.platform.OS.GraphicsAPIs)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr vulkan_highest_supported_version_;
  ::google::protobuf::internal::ArenaStringPtr d3d_highest_supported_version_;
  bool metal_supported_;
  bool vulkan_supported_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5fpublic_2fapp_2fplatform_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OS_Wine : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_public.app.platform.OS.Wine) */ {
 public:
  OS_Wine();
  virtual ~OS_Wine();

  OS_Wine(const OS_Wine& from);

  inline OS_Wine& operator=(const OS_Wine& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OS_Wine(OS_Wine&& from) noexcept
    : OS_Wine() {
    *this = ::std::move(from);
  }

  inline OS_Wine& operator=(OS_Wine&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OS_Wine& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OS_Wine* internal_default_instance() {
    return reinterpret_cast<const OS_Wine*>(
               &_OS_Wine_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(OS_Wine* other);
  friend void swap(OS_Wine& a, OS_Wine& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OS_Wine* New() const final {
    return CreateMaybeMessage<OS_Wine>(NULL);
  }

  OS_Wine* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OS_Wine>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OS_Wine& from);
  void MergeFrom(const OS_Wine& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OS_Wine* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string host_os = 2;
  void clear_host_os();
  static const int kHostOsFieldNumber = 2;
  const ::std::string& host_os() const;
  void set_host_os(const ::std::string& value);
  #if LANG_CXX11
  void set_host_os(::std::string&& value);
  #endif
  void set_host_os(const char* value);
  void set_host_os(const char* value, size_t size);
  ::std::string* mutable_host_os();
  ::std::string* release_host_os();
  void set_allocated_host_os(::std::string* host_os);

  // @@protoc_insertion_point(class_scope:eve_public.app.platform.OS.Wine)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr host_os_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5fpublic_2fapp_2fplatform_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OS_StreamingService : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_public.app.platform.OS.StreamingService) */ {
 public:
  OS_StreamingService();
  virtual ~OS_StreamingService();

  OS_StreamingService(const OS_StreamingService& from);

  inline OS_StreamingService& operator=(const OS_StreamingService& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OS_StreamingService(OS_StreamingService&& from) noexcept
    : OS_StreamingService() {
    *this = ::std::move(from);
  }

  inline OS_StreamingService& operator=(OS_StreamingService&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OS_StreamingService& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OS_StreamingService* internal_default_instance() {
    return reinterpret_cast<const OS_StreamingService*>(
               &_OS_StreamingService_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(OS_StreamingService* other);
  friend void swap(OS_StreamingService& a, OS_StreamingService& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OS_StreamingService* New() const final {
    return CreateMaybeMessage<OS_StreamingService>(NULL);
  }

  OS_StreamingService* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OS_StreamingService>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OS_StreamingService& from);
  void MergeFrom(const OS_StreamingService& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OS_StreamingService* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OS_StreamingService_Provider Provider;
  static const Provider PROVIDER_UNSPECIFIED =
    OS_StreamingService_Provider_PROVIDER_UNSPECIFIED;
  static const Provider PROVIDER_UNKNOWN =
    OS_StreamingService_Provider_PROVIDER_UNKNOWN;
  static const Provider PROVIDER_INTEL =
    OS_StreamingService_Provider_PROVIDER_INTEL;
  static inline bool Provider_IsValid(int value) {
    return OS_StreamingService_Provider_IsValid(value);
  }
  static const Provider Provider_MIN =
    OS_StreamingService_Provider_Provider_MIN;
  static const Provider Provider_MAX =
    OS_StreamingService_Provider_Provider_MAX;
  static const int Provider_ARRAYSIZE =
    OS_StreamingService_Provider_Provider_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Provider_descriptor() {
    return OS_StreamingService_Provider_descriptor();
  }
  static inline const ::std::string& Provider_Name(Provider value) {
    return OS_StreamingService_Provider_Name(value);
  }
  static inline bool Provider_Parse(const ::std::string& name,
      Provider* value) {
    return OS_StreamingService_Provider_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .eve_public.app.platform.OS.StreamingService.Provider provider = 1;
  void clear_provider();
  static const int kProviderFieldNumber = 1;
  ::eve_public::app::platform::OS_StreamingService_Provider provider() const;
  void set_provider(::eve_public::app::platform::OS_StreamingService_Provider value);

  // @@protoc_insertion_point(class_scope:eve_public.app.platform.OS.StreamingService)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int provider_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5fpublic_2fapp_2fplatform_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OS : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_public.app.platform.OS) */ {
 public:
  OS();
  virtual ~OS();

  OS(const OS& from);

  inline OS& operator=(const OS& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OS(OS&& from) noexcept
    : OS() {
    *this = ::std::move(from);
  }

  inline OS& operator=(OS&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OS& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OS* internal_default_instance() {
    return reinterpret_cast<const OS*>(
               &_OS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(OS* other);
  friend void swap(OS& a, OS& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OS* New() const final {
    return CreateMaybeMessage<OS>(NULL);
  }

  OS* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OS>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OS& from);
  void MergeFrom(const OS& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OS* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OS_GraphicsAPIs GraphicsAPIs;
  typedef OS_Wine Wine;
  typedef OS_StreamingService StreamingService;

  typedef OS_Kind Kind;
  static const Kind KIND_UNSPECIFIED =
    OS_Kind_KIND_UNSPECIFIED;
  static const Kind KIND_WINDOWS =
    OS_Kind_KIND_WINDOWS;
  static const Kind KIND_MACOS =
    OS_Kind_KIND_MACOS;
  static const Kind KIND_WINE =
    OS_Kind_KIND_WINE;
  static inline bool Kind_IsValid(int value) {
    return OS_Kind_IsValid(value);
  }
  static const Kind Kind_MIN =
    OS_Kind_Kind_MIN;
  static const Kind Kind_MAX =
    OS_Kind_Kind_MAX;
  static const int Kind_ARRAYSIZE =
    OS_Kind_Kind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Kind_descriptor() {
    return OS_Kind_descriptor();
  }
  static inline const ::std::string& Kind_Name(Kind value) {
    return OS_Kind_Name(value);
  }
  static inline bool Kind_Parse(const ::std::string& name,
      Kind* value) {
    return OS_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string major_version = 4;
  void clear_major_version();
  static const int kMajorVersionFieldNumber = 4;
  const ::std::string& major_version() const;
  void set_major_version(const ::std::string& value);
  #if LANG_CXX11
  void set_major_version(::std::string&& value);
  #endif
  void set_major_version(const char* value);
  void set_major_version(const char* value, size_t size);
  ::std::string* mutable_major_version();
  ::std::string* release_major_version();
  void set_allocated_major_version(::std::string* major_version);

  // string minor_version = 5;
  void clear_minor_version();
  static const int kMinorVersionFieldNumber = 5;
  const ::std::string& minor_version() const;
  void set_minor_version(const ::std::string& value);
  #if LANG_CXX11
  void set_minor_version(::std::string&& value);
  #endif
  void set_minor_version(const char* value);
  void set_minor_version(const char* value, size_t size);
  ::std::string* mutable_minor_version();
  ::std::string* release_minor_version();
  void set_allocated_minor_version(::std::string* minor_version);

  // string build_number = 6;
  void clear_build_number();
  static const int kBuildNumberFieldNumber = 6;
  const ::std::string& build_number() const;
  void set_build_number(const ::std::string& value);
  #if LANG_CXX11
  void set_build_number(::std::string&& value);
  #endif
  void set_build_number(const char* value);
  void set_build_number(const char* value, size_t size);
  ::std::string* mutable_build_number();
  ::std::string* release_build_number();
  void set_allocated_build_number(::std::string* build_number);

  // string kernel_version = 7;
  void clear_kernel_version();
  static const int kKernelVersionFieldNumber = 7;
  const ::std::string& kernel_version() const;
  void set_kernel_version(const ::std::string& value);
  #if LANG_CXX11
  void set_kernel_version(::std::string&& value);
  #endif
  void set_kernel_version(const char* value);
  void set_kernel_version(const char* value, size_t size);
  ::std::string* mutable_kernel_version();
  ::std::string* release_kernel_version();
  void set_allocated_kernel_version(::std::string* kernel_version);

  // string username = 8;
  void clear_username();
  static const int kUsernameFieldNumber = 8;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // string user_locale = 9;
  void clear_user_locale();
  static const int kUserLocaleFieldNumber = 9;
  const ::std::string& user_locale() const;
  void set_user_locale(const ::std::string& value);
  #if LANG_CXX11
  void set_user_locale(::std::string&& value);
  #endif
  void set_user_locale(const char* value);
  void set_user_locale(const char* value, size_t size);
  ::std::string* mutable_user_locale();
  ::std::string* release_user_locale();
  void set_allocated_user_locale(::std::string* user_locale);

  // .eve_public.app.platform.OS.GraphicsAPIs graphics_apis = 11;
  bool has_graphics_apis() const;
  void clear_graphics_apis();
  static const int kGraphicsApisFieldNumber = 11;
  private:
  const ::eve_public::app::platform::OS_GraphicsAPIs& _internal_graphics_apis() const;
  public:
  const ::eve_public::app::platform::OS_GraphicsAPIs& graphics_apis() const;
  ::eve_public::app::platform::OS_GraphicsAPIs* release_graphics_apis();
  ::eve_public::app::platform::OS_GraphicsAPIs* mutable_graphics_apis();
  void set_allocated_graphics_apis(::eve_public::app::platform::OS_GraphicsAPIs* graphics_apis);

  // .eve_public.app.platform.OS.Wine wine = 12;
  bool has_wine() const;
  void clear_wine();
  static const int kWineFieldNumber = 12;
  private:
  const ::eve_public::app::platform::OS_Wine& _internal_wine() const;
  public:
  const ::eve_public::app::platform::OS_Wine& wine() const;
  ::eve_public::app::platform::OS_Wine* release_wine();
  ::eve_public::app::platform::OS_Wine* mutable_wine();
  void set_allocated_wine(::eve_public::app::platform::OS_Wine* wine);

  // .eve_public.app.platform.OS.StreamingService streaming_service = 13;
  bool has_streaming_service() const;
  void clear_streaming_service();
  static const int kStreamingServiceFieldNumber = 13;
  private:
  const ::eve_public::app::platform::OS_StreamingService& _internal_streaming_service() const;
  public:
  const ::eve_public::app::platform::OS_StreamingService& streaming_service() const;
  ::eve_public::app::platform::OS_StreamingService* release_streaming_service();
  ::eve_public::app::platform::OS_StreamingService* mutable_streaming_service();
  void set_allocated_streaming_service(::eve_public::app::platform::OS_StreamingService* streaming_service);

  // .eve_public.app.platform.OS.Kind type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::eve_public::app::platform::OS_Kind type() const;
  void set_type(::eve_public::app::platform::OS_Kind value);

  // .eve_public.app.platform.Bitness bitness = 3;
  void clear_bitness();
  static const int kBitnessFieldNumber = 3;
  ::eve_public::app::platform::Bitness bitness() const;
  void set_bitness(::eve_public::app::platform::Bitness value);

  // bool is_remote_session = 10;
  void clear_is_remote_session();
  static const int kIsRemoteSessionFieldNumber = 10;
  bool is_remote_session() const;
  void set_is_remote_session(bool value);

  // @@protoc_insertion_point(class_scope:eve_public.app.platform.OS)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr major_version_;
  ::google::protobuf::internal::ArenaStringPtr minor_version_;
  ::google::protobuf::internal::ArenaStringPtr build_number_;
  ::google::protobuf::internal::ArenaStringPtr kernel_version_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr user_locale_;
  ::eve_public::app::platform::OS_GraphicsAPIs* graphics_apis_;
  ::eve_public::app::platform::OS_Wine* wine_;
  ::eve_public::app::platform::OS_StreamingService* streaming_service_;
  int type_;
  int bitness_;
  bool is_remote_session_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5fpublic_2fapp_2fplatform_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Machine_CPU : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_public.app.platform.Machine.CPU) */ {
 public:
  Machine_CPU();
  virtual ~Machine_CPU();

  Machine_CPU(const Machine_CPU& from);

  inline Machine_CPU& operator=(const Machine_CPU& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Machine_CPU(Machine_CPU&& from) noexcept
    : Machine_CPU() {
    *this = ::std::move(from);
  }

  inline Machine_CPU& operator=(Machine_CPU&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Machine_CPU& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Machine_CPU* internal_default_instance() {
    return reinterpret_cast<const Machine_CPU*>(
               &_Machine_CPU_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Machine_CPU* other);
  friend void swap(Machine_CPU& a, Machine_CPU& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Machine_CPU* New() const final {
    return CreateMaybeMessage<Machine_CPU>(NULL);
  }

  Machine_CPU* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Machine_CPU>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Machine_CPU& from);
  void MergeFrom(const Machine_CPU& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Machine_CPU* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Machine_CPU_Architecture Architecture;
  static const Architecture ARCHITECTURE_UNSPECIFIED =
    Machine_CPU_Architecture_ARCHITECTURE_UNSPECIFIED;
  static const Architecture ARCHITECTURE_X86 =
    Machine_CPU_Architecture_ARCHITECTURE_X86;
  static const Architecture ARCHITECTURE_X86_64 =
    Machine_CPU_Architecture_ARCHITECTURE_X86_64;
  static const Architecture ARCHITECTURE_ARM =
    Machine_CPU_Architecture_ARCHITECTURE_ARM;
  static const Architecture ARCHITECTURE_ARM64 =
    Machine_CPU_Architecture_ARCHITECTURE_ARM64;
  static inline bool Architecture_IsValid(int value) {
    return Machine_CPU_Architecture_IsValid(value);
  }
  static const Architecture Architecture_MIN =
    Machine_CPU_Architecture_Architecture_MIN;
  static const Architecture Architecture_MAX =
    Machine_CPU_Architecture_Architecture_MAX;
  static const int Architecture_ARRAYSIZE =
    Machine_CPU_Architecture_Architecture_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Architecture_descriptor() {
    return Machine_CPU_Architecture_descriptor();
  }
  static inline const ::std::string& Architecture_Name(Architecture value) {
    return Machine_CPU_Architecture_Name(value);
  }
  static inline bool Architecture_Parse(const ::std::string& name,
      Architecture* value) {
    return Machine_CPU_Architecture_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated string extensions = 8;
  int extensions_size() const;
  void clear_extensions();
  static const int kExtensionsFieldNumber = 8;
  const ::std::string& extensions(int index) const;
  ::std::string* mutable_extensions(int index);
  void set_extensions(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_extensions(int index, ::std::string&& value);
  #endif
  void set_extensions(int index, const char* value);
  void set_extensions(int index, const char* value, size_t size);
  ::std::string* add_extensions();
  void add_extensions(const ::std::string& value);
  #if LANG_CXX11
  void add_extensions(::std::string&& value);
  #endif
  void add_extensions(const char* value);
  void add_extensions(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& extensions() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_extensions();

  // string brand = 3;
  void clear_brand();
  static const int kBrandFieldNumber = 3;
  const ::std::string& brand() const;
  void set_brand(const ::std::string& value);
  #if LANG_CXX11
  void set_brand(::std::string&& value);
  #endif
  void set_brand(const char* value);
  void set_brand(const char* value, size_t size);
  ::std::string* mutable_brand();
  ::std::string* release_brand();
  void set_allocated_brand(::std::string* brand);

  // string vendor = 4;
  void clear_vendor();
  static const int kVendorFieldNumber = 4;
  const ::std::string& vendor() const;
  void set_vendor(const ::std::string& value);
  #if LANG_CXX11
  void set_vendor(::std::string&& value);
  #endif
  void set_vendor(const char* value);
  void set_vendor(const char* value, size_t size);
  ::std::string* mutable_vendor();
  ::std::string* release_vendor();
  void set_allocated_vendor(::std::string* vendor);

  // .eve_public.app.platform.Bitness bitness = 1;
  void clear_bitness();
  static const int kBitnessFieldNumber = 1;
  ::eve_public::app::platform::Bitness bitness() const;
  void set_bitness(::eve_public::app::platform::Bitness value);

  // int32 logical_core_count = 2;
  void clear_logical_core_count();
  static const int kLogicalCoreCountFieldNumber = 2;
  ::google::protobuf::int32 logical_core_count() const;
  void set_logical_core_count(::google::protobuf::int32 value);

  // int32 model = 5;
  void clear_model();
  static const int kModelFieldNumber = 5;
  ::google::protobuf::int32 model() const;
  void set_model(::google::protobuf::int32 value);

  // int32 stepping = 6;
  void clear_stepping();
  static const int kSteppingFieldNumber = 6;
  ::google::protobuf::int32 stepping() const;
  void set_stepping(::google::protobuf::int32 value);

  // .eve_public.app.platform.Machine.CPU.Architecture architecture = 7;
  void clear_architecture();
  static const int kArchitectureFieldNumber = 7;
  ::eve_public::app::platform::Machine_CPU_Architecture architecture() const;
  void set_architecture(::eve_public::app::platform::Machine_CPU_Architecture value);

  // uint32 frequency = 9;
  void clear_frequency();
  static const int kFrequencyFieldNumber = 9;
  ::google::protobuf::uint32 frequency() const;
  void set_frequency(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:eve_public.app.platform.Machine.CPU)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> extensions_;
  ::google::protobuf::internal::ArenaStringPtr brand_;
  ::google::protobuf::internal::ArenaStringPtr vendor_;
  int bitness_;
  ::google::protobuf::int32 logical_core_count_;
  ::google::protobuf::int32 model_;
  ::google::protobuf::int32 stepping_;
  int architecture_;
  ::google::protobuf::uint32 frequency_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5fpublic_2fapp_2fplatform_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Machine_VM : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_public.app.platform.Machine.VM) */ {
 public:
  Machine_VM();
  virtual ~Machine_VM();

  Machine_VM(const Machine_VM& from);

  inline Machine_VM& operator=(const Machine_VM& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Machine_VM(Machine_VM&& from) noexcept
    : Machine_VM() {
    *this = ::std::move(from);
  }

  inline Machine_VM& operator=(Machine_VM&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Machine_VM& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Machine_VM* internal_default_instance() {
    return reinterpret_cast<const Machine_VM*>(
               &_Machine_VM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Machine_VM* other);
  friend void swap(Machine_VM& a, Machine_VM& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Machine_VM* New() const final {
    return CreateMaybeMessage<Machine_VM>(NULL);
  }

  Machine_VM* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Machine_VM>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Machine_VM& from);
  void MergeFrom(const Machine_VM& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Machine_VM* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string hypervisor_name = 3;
  void clear_hypervisor_name();
  static const int kHypervisorNameFieldNumber = 3;
  const ::std::string& hypervisor_name() const;
  void set_hypervisor_name(const ::std::string& value);
  #if LANG_CXX11
  void set_hypervisor_name(::std::string&& value);
  #endif
  void set_hypervisor_name(const char* value);
  void set_hypervisor_name(const char* value, size_t size);
  ::std::string* mutable_hypervisor_name();
  ::std::string* release_hypervisor_name();
  void set_allocated_hypervisor_name(::std::string* hypervisor_name);

  // bool is_suspected_vm = 1;
  void clear_is_suspected_vm();
  static const int kIsSuspectedVmFieldNumber = 1;
  bool is_suspected_vm() const;
  void set_is_suspected_vm(bool value);

  // bool has_hypervisor_bit = 2;
  void clear_has_hypervisor_bit();
  static const int kHasHypervisorBitFieldNumber = 2;
  bool has_hypervisor_bit() const;
  void set_has_hypervisor_bit(bool value);

  // bool is_hypervisor_guest_os = 4;
  void clear_is_hypervisor_guest_os();
  static const int kIsHypervisorGuestOsFieldNumber = 4;
  bool is_hypervisor_guest_os() const;
  void set_is_hypervisor_guest_os(bool value);

  // bool has_vm_execution_timing = 5;
  void clear_has_vm_execution_timing();
  static const int kHasVmExecutionTimingFieldNumber = 5;
  bool has_vm_execution_timing() const;
  void set_has_vm_execution_timing(bool value);

  // @@protoc_insertion_point(class_scope:eve_public.app.platform.Machine.VM)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hypervisor_name_;
  bool is_suspected_vm_;
  bool has_hypervisor_bit_;
  bool is_hypervisor_guest_os_;
  bool has_vm_execution_timing_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5fpublic_2fapp_2fplatform_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Machine_Monitor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_public.app.platform.Machine.Monitor) */ {
 public:
  Machine_Monitor();
  virtual ~Machine_Monitor();

  Machine_Monitor(const Machine_Monitor& from);

  inline Machine_Monitor& operator=(const Machine_Monitor& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Machine_Monitor(Machine_Monitor&& from) noexcept
    : Machine_Monitor() {
    *this = ::std::move(from);
  }

  inline Machine_Monitor& operator=(Machine_Monitor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Machine_Monitor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Machine_Monitor* internal_default_instance() {
    return reinterpret_cast<const Machine_Monitor*>(
               &_Machine_Monitor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Machine_Monitor* other);
  friend void swap(Machine_Monitor& a, Machine_Monitor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Machine_Monitor* New() const final {
    return CreateMaybeMessage<Machine_Monitor>(NULL);
  }

  Machine_Monitor* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Machine_Monitor>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Machine_Monitor& from);
  void MergeFrom(const Machine_Monitor& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Machine_Monitor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // int32 horizontal_resolution = 2;
  void clear_horizontal_resolution();
  static const int kHorizontalResolutionFieldNumber = 2;
  ::google::protobuf::int32 horizontal_resolution() const;
  void set_horizontal_resolution(::google::protobuf::int32 value);

  // int32 vertical_resolution = 3;
  void clear_vertical_resolution();
  static const int kVerticalResolutionFieldNumber = 3;
  ::google::protobuf::int32 vertical_resolution() const;
  void set_vertical_resolution(::google::protobuf::int32 value);

  // int32 bits_per_color = 4;
  void clear_bits_per_color();
  static const int kBitsPerColorFieldNumber = 4;
  ::google::protobuf::int32 bits_per_color() const;
  void set_bits_per_color(::google::protobuf::int32 value);

  // int32 refresh_rate = 5;
  void clear_refresh_rate();
  static const int kRefreshRateFieldNumber = 5;
  ::google::protobuf::int32 refresh_rate() const;
  void set_refresh_rate(::google::protobuf::int32 value);

  // int32 dpi_scaling_percent = 6;
  void clear_dpi_scaling_percent();
  static const int kDpiScalingPercentFieldNumber = 6;
  ::google::protobuf::int32 dpi_scaling_percent() const;
  void set_dpi_scaling_percent(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:eve_public.app.platform.Machine.Monitor)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 horizontal_resolution_;
  ::google::protobuf::int32 vertical_resolution_;
  ::google::protobuf::int32 bits_per_color_;
  ::google::protobuf::int32 refresh_rate_;
  ::google::protobuf::int32 dpi_scaling_percent_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5fpublic_2fapp_2fplatform_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Machine_GPU_Driver : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_public.app.platform.Machine.GPU.Driver) */ {
 public:
  Machine_GPU_Driver();
  virtual ~Machine_GPU_Driver();

  Machine_GPU_Driver(const Machine_GPU_Driver& from);

  inline Machine_GPU_Driver& operator=(const Machine_GPU_Driver& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Machine_GPU_Driver(Machine_GPU_Driver&& from) noexcept
    : Machine_GPU_Driver() {
    *this = ::std::move(from);
  }

  inline Machine_GPU_Driver& operator=(Machine_GPU_Driver&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Machine_GPU_Driver& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Machine_GPU_Driver* internal_default_instance() {
    return reinterpret_cast<const Machine_GPU_Driver*>(
               &_Machine_GPU_Driver_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Machine_GPU_Driver* other);
  friend void swap(Machine_GPU_Driver& a, Machine_GPU_Driver& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Machine_GPU_Driver* New() const final {
    return CreateMaybeMessage<Machine_GPU_Driver>(NULL);
  }

  Machine_GPU_Driver* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Machine_GPU_Driver>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Machine_GPU_Driver& from);
  void MergeFrom(const Machine_GPU_Driver& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Machine_GPU_Driver* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string date = 1;
  void clear_date();
  static const int kDateFieldNumber = 1;
  const ::std::string& date() const;
  void set_date(const ::std::string& value);
  #if LANG_CXX11
  void set_date(::std::string&& value);
  #endif
  void set_date(const char* value);
  void set_date(const char* value, size_t size);
  ::std::string* mutable_date();
  ::std::string* release_date();
  void set_allocated_date(::std::string* date);

  // string vendor = 2;
  void clear_vendor();
  static const int kVendorFieldNumber = 2;
  const ::std::string& vendor() const;
  void set_vendor(const ::std::string& value);
  #if LANG_CXX11
  void set_vendor(::std::string&& value);
  #endif
  void set_vendor(const char* value);
  void set_vendor(const char* value, size_t size);
  ::std::string* mutable_vendor();
  ::std::string* release_vendor();
  void set_allocated_vendor(::std::string* vendor);

  // string version = 3;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:eve_public.app.platform.Machine.GPU.Driver)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr date_;
  ::google::protobuf::internal::ArenaStringPtr vendor_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5fpublic_2fapp_2fplatform_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Machine_GPU : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_public.app.platform.Machine.GPU) */ {
 public:
  Machine_GPU();
  virtual ~Machine_GPU();

  Machine_GPU(const Machine_GPU& from);

  inline Machine_GPU& operator=(const Machine_GPU& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Machine_GPU(Machine_GPU&& from) noexcept
    : Machine_GPU() {
    *this = ::std::move(from);
  }

  inline Machine_GPU& operator=(Machine_GPU&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Machine_GPU& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Machine_GPU* internal_default_instance() {
    return reinterpret_cast<const Machine_GPU*>(
               &_Machine_GPU_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Machine_GPU* other);
  friend void swap(Machine_GPU& a, Machine_GPU& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Machine_GPU* New() const final {
    return CreateMaybeMessage<Machine_GPU>(NULL);
  }

  Machine_GPU* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Machine_GPU>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Machine_GPU& from);
  void MergeFrom(const Machine_GPU& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Machine_GPU* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Machine_GPU_Driver Driver;

  // accessors -------------------------------------------------------

  // string description = 1;
  void clear_description();
  static const int kDescriptionFieldNumber = 1;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // .eve_public.app.platform.Machine.GPU.Driver driver = 6;
  bool has_driver() const;
  void clear_driver();
  static const int kDriverFieldNumber = 6;
  private:
  const ::eve_public::app::platform::Machine_GPU_Driver& _internal_driver() const;
  public:
  const ::eve_public::app::platform::Machine_GPU_Driver& driver() const;
  ::eve_public::app::platform::Machine_GPU_Driver* release_driver();
  ::eve_public::app::platform::Machine_GPU_Driver* mutable_driver();
  void set_allocated_driver(::eve_public::app::platform::Machine_GPU_Driver* driver);

  // int32 vendor_id = 2;
  void clear_vendor_id();
  static const int kVendorIdFieldNumber = 2;
  ::google::protobuf::int32 vendor_id() const;
  void set_vendor_id(::google::protobuf::int32 value);

  // int32 device_id = 3;
  void clear_device_id();
  static const int kDeviceIdFieldNumber = 3;
  ::google::protobuf::int32 device_id() const;
  void set_device_id(::google::protobuf::int32 value);

  // int64 video_memory = 5;
  void clear_video_memory();
  static const int kVideoMemoryFieldNumber = 5;
  ::google::protobuf::int64 video_memory() const;
  void set_video_memory(::google::protobuf::int64 value);

  // int32 revision = 4;
  void clear_revision();
  static const int kRevisionFieldNumber = 4;
  ::google::protobuf::int32 revision() const;
  void set_revision(::google::protobuf::int32 value);

  // uint32 core_count = 7;
  void clear_core_count();
  static const int kCoreCountFieldNumber = 7;
  ::google::protobuf::uint32 core_count() const;
  void set_core_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:eve_public.app.platform.Machine.GPU)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::eve_public::app::platform::Machine_GPU_Driver* driver_;
  ::google::protobuf::int32 vendor_id_;
  ::google::protobuf::int32 device_id_;
  ::google::protobuf::int64 video_memory_;
  ::google::protobuf::int32 revision_;
  ::google::protobuf::uint32 core_count_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5fpublic_2fapp_2fplatform_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Machine_NetworkAdapter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_public.app.platform.Machine.NetworkAdapter) */ {
 public:
  Machine_NetworkAdapter();
  virtual ~Machine_NetworkAdapter();

  Machine_NetworkAdapter(const Machine_NetworkAdapter& from);

  inline Machine_NetworkAdapter& operator=(const Machine_NetworkAdapter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Machine_NetworkAdapter(Machine_NetworkAdapter&& from) noexcept
    : Machine_NetworkAdapter() {
    *this = ::std::move(from);
  }

  inline Machine_NetworkAdapter& operator=(Machine_NetworkAdapter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Machine_NetworkAdapter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Machine_NetworkAdapter* internal_default_instance() {
    return reinterpret_cast<const Machine_NetworkAdapter*>(
               &_Machine_NetworkAdapter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Machine_NetworkAdapter* other);
  friend void swap(Machine_NetworkAdapter& a, Machine_NetworkAdapter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Machine_NetworkAdapter* New() const final {
    return CreateMaybeMessage<Machine_NetworkAdapter>(NULL);
  }

  Machine_NetworkAdapter* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Machine_NetworkAdapter>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Machine_NetworkAdapter& from);
  void MergeFrom(const Machine_NetworkAdapter& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Machine_NetworkAdapter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // bytes mac_address = 2;
  void clear_mac_address();
  static const int kMacAddressFieldNumber = 2;
  const ::std::string& mac_address() const;
  void set_mac_address(const ::std::string& value);
  #if LANG_CXX11
  void set_mac_address(::std::string&& value);
  #endif
  void set_mac_address(const char* value);
  void set_mac_address(const void* value, size_t size);
  ::std::string* mutable_mac_address();
  ::std::string* release_mac_address();
  void set_allocated_mac_address(::std::string* mac_address);

  // bytes uuid = 3;
  void clear_uuid();
  static const int kUuidFieldNumber = 3;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const void* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // @@protoc_insertion_point(class_scope:eve_public.app.platform.Machine.NetworkAdapter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr mac_address_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5fpublic_2fapp_2fplatform_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Machine_HardDrive : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_public.app.platform.Machine.HardDrive) */ {
 public:
  Machine_HardDrive();
  virtual ~Machine_HardDrive();

  Machine_HardDrive(const Machine_HardDrive& from);

  inline Machine_HardDrive& operator=(const Machine_HardDrive& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Machine_HardDrive(Machine_HardDrive&& from) noexcept
    : Machine_HardDrive() {
    *this = ::std::move(from);
  }

  inline Machine_HardDrive& operator=(Machine_HardDrive&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Machine_HardDrive& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Machine_HardDrive* internal_default_instance() {
    return reinterpret_cast<const Machine_HardDrive*>(
               &_Machine_HardDrive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Machine_HardDrive* other);
  friend void swap(Machine_HardDrive& a, Machine_HardDrive& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Machine_HardDrive* New() const final {
    return CreateMaybeMessage<Machine_HardDrive>(NULL);
  }

  Machine_HardDrive* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Machine_HardDrive>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Machine_HardDrive& from);
  void MergeFrom(const Machine_HardDrive& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Machine_HardDrive* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Machine_HardDrive_DriveType DriveType;
  static const DriveType DRIVETYPE_UNSPECIFIED =
    Machine_HardDrive_DriveType_DRIVETYPE_UNSPECIFIED;
  static const DriveType DRIVETYPE_SSD =
    Machine_HardDrive_DriveType_DRIVETYPE_SSD;
  static const DriveType DRIVETYPE_HDD =
    Machine_HardDrive_DriveType_DRIVETYPE_HDD;
  static inline bool DriveType_IsValid(int value) {
    return Machine_HardDrive_DriveType_IsValid(value);
  }
  static const DriveType DriveType_MIN =
    Machine_HardDrive_DriveType_DriveType_MIN;
  static const DriveType DriveType_MAX =
    Machine_HardDrive_DriveType_DriveType_MAX;
  static const int DriveType_ARRAYSIZE =
    Machine_HardDrive_DriveType_DriveType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DriveType_descriptor() {
    return Machine_HardDrive_DriveType_descriptor();
  }
  static inline const ::std::string& DriveType_Name(DriveType value) {
    return Machine_HardDrive_DriveType_Name(value);
  }
  static inline bool DriveType_Parse(const ::std::string& name,
      DriveType* value) {
    return Machine_HardDrive_DriveType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // uint64 size = 3;
  void clear_size();
  static const int kSizeFieldNumber = 3;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // .eve_public.app.platform.Machine.HardDrive.DriveType drive_type = 2;
  void clear_drive_type();
  static const int kDriveTypeFieldNumber = 2;
  ::eve_public::app::platform::Machine_HardDrive_DriveType drive_type() const;
  void set_drive_type(::eve_public::app::platform::Machine_HardDrive_DriveType value);

  // @@protoc_insertion_point(class_scope:eve_public.app.platform.Machine.HardDrive)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint64 size_;
  int drive_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5fpublic_2fapp_2fplatform_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Machine : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_public.app.platform.Machine) */ {
 public:
  Machine();
  virtual ~Machine();

  Machine(const Machine& from);

  inline Machine& operator=(const Machine& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Machine(Machine&& from) noexcept
    : Machine() {
    *this = ::std::move(from);
  }

  inline Machine& operator=(Machine&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Machine& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Machine* internal_default_instance() {
    return reinterpret_cast<const Machine*>(
               &_Machine_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(Machine* other);
  friend void swap(Machine& a, Machine& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Machine* New() const final {
    return CreateMaybeMessage<Machine>(NULL);
  }

  Machine* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Machine>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Machine& from);
  void MergeFrom(const Machine& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Machine* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Machine_CPU CPU;
  typedef Machine_VM VM;
  typedef Machine_Monitor Monitor;
  typedef Machine_GPU GPU;
  typedef Machine_NetworkAdapter NetworkAdapter;
  typedef Machine_HardDrive HardDrive;

  typedef Machine_BatteryDetection BatteryDetection;
  static const BatteryDetection BATTERY_UNSPECIFIED =
    Machine_BatteryDetection_BATTERY_UNSPECIFIED;
  static const BatteryDetection BATTERY_DETECTED =
    Machine_BatteryDetection_BATTERY_DETECTED;
  static const BatteryDetection BATTERY_NOT_DETECTED =
    Machine_BatteryDetection_BATTERY_NOT_DETECTED;
  static inline bool BatteryDetection_IsValid(int value) {
    return Machine_BatteryDetection_IsValid(value);
  }
  static const BatteryDetection BatteryDetection_MIN =
    Machine_BatteryDetection_BatteryDetection_MIN;
  static const BatteryDetection BatteryDetection_MAX =
    Machine_BatteryDetection_BatteryDetection_MAX;
  static const int BatteryDetection_ARRAYSIZE =
    Machine_BatteryDetection_BatteryDetection_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BatteryDetection_descriptor() {
    return Machine_BatteryDetection_descriptor();
  }
  static inline const ::std::string& BatteryDetection_Name(BatteryDetection value) {
    return Machine_BatteryDetection_Name(value);
  }
  static inline bool BatteryDetection_Parse(const ::std::string& name,
      BatteryDetection* value) {
    return Machine_BatteryDetection_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .eve_public.app.platform.Machine.Monitor monitors = 8;
  int monitors_size() const;
  void clear_monitors();
  static const int kMonitorsFieldNumber = 8;
  ::eve_public::app::platform::Machine_Monitor* mutable_monitors(int index);
  ::google::protobuf::RepeatedPtrField< ::eve_public::app::platform::Machine_Monitor >*
      mutable_monitors();
  const ::eve_public::app::platform::Machine_Monitor& monitors(int index) const;
  ::eve_public::app::platform::Machine_Monitor* add_monitors();
  const ::google::protobuf::RepeatedPtrField< ::eve_public::app::platform::Machine_Monitor >&
      monitors() const;

  // repeated .eve_public.app.platform.Machine.GPU gpus = 9;
  int gpus_size() const;
  void clear_gpus();
  static const int kGpusFieldNumber = 9;
  ::eve_public::app::platform::Machine_GPU* mutable_gpus(int index);
  ::google::protobuf::RepeatedPtrField< ::eve_public::app::platform::Machine_GPU >*
      mutable_gpus();
  const ::eve_public::app::platform::Machine_GPU& gpus(int index) const;
  ::eve_public::app::platform::Machine_GPU* add_gpus();
  const ::google::protobuf::RepeatedPtrField< ::eve_public::app::platform::Machine_GPU >&
      gpus() const;

  // repeated .eve_public.app.platform.Machine.NetworkAdapter network_adapters = 10;
  int network_adapters_size() const;
  void clear_network_adapters();
  static const int kNetworkAdaptersFieldNumber = 10;
  ::eve_public::app::platform::Machine_NetworkAdapter* mutable_network_adapters(int index);
  ::google::protobuf::RepeatedPtrField< ::eve_public::app::platform::Machine_NetworkAdapter >*
      mutable_network_adapters();
  const ::eve_public::app::platform::Machine_NetworkAdapter& network_adapters(int index) const;
  ::eve_public::app::platform::Machine_NetworkAdapter* add_network_adapters();
  const ::google::protobuf::RepeatedPtrField< ::eve_public::app::platform::Machine_NetworkAdapter >&
      network_adapters() const;

  // repeated .eve_public.app.platform.Machine.HardDrive hard_drives = 12;
  int hard_drives_size() const;
  void clear_hard_drives();
  static const int kHardDrivesFieldNumber = 12;
  ::eve_public::app::platform::Machine_HardDrive* mutable_hard_drives(int index);
  ::google::protobuf::RepeatedPtrField< ::eve_public::app::platform::Machine_HardDrive >*
      mutable_hard_drives();
  const ::eve_public::app::platform::Machine_HardDrive& hard_drives(int index) const;
  ::eve_public::app::platform::Machine_HardDrive* add_hard_drives();
  const ::google::protobuf::RepeatedPtrField< ::eve_public::app::platform::Machine_HardDrive >&
      hard_drives() const;

  // string model = 1;
  void clear_model();
  static const int kModelFieldNumber = 1;
  const ::std::string& model() const;
  void set_model(const ::std::string& value);
  #if LANG_CXX11
  void set_model(::std::string&& value);
  #endif
  void set_model(const char* value);
  void set_model(const char* value, size_t size);
  ::std::string* mutable_model();
  ::std::string* release_model();
  void set_allocated_model(::std::string* model);

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // bytes uuid = 3;
  void clear_uuid();
  static const int kUuidFieldNumber = 3;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const void* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // .eve_public.app.platform.Machine.CPU cpu = 6;
  bool has_cpu() const;
  void clear_cpu();
  static const int kCpuFieldNumber = 6;
  private:
  const ::eve_public::app::platform::Machine_CPU& _internal_cpu() const;
  public:
  const ::eve_public::app::platform::Machine_CPU& cpu() const;
  ::eve_public::app::platform::Machine_CPU* release_cpu();
  ::eve_public::app::platform::Machine_CPU* mutable_cpu();
  void set_allocated_cpu(::eve_public::app::platform::Machine_CPU* cpu);

  // .eve_public.app.platform.Machine.VM vm = 7;
  bool has_vm() const;
  void clear_vm();
  static const int kVmFieldNumber = 7;
  private:
  const ::eve_public::app::platform::Machine_VM& _internal_vm() const;
  public:
  const ::eve_public::app::platform::Machine_VM& vm() const;
  ::eve_public::app::platform::Machine_VM* release_vm();
  ::eve_public::app::platform::Machine_VM* mutable_vm();
  void set_allocated_vm(::eve_public::app::platform::Machine_VM* vm);

  // int64 total_memory = 4;
  void clear_total_memory();
  static const int kTotalMemoryFieldNumber = 4;
  ::google::protobuf::int64 total_memory() const;
  void set_total_memory(::google::protobuf::int64 value);

  // int32 monitor_count = 5;
  void clear_monitor_count();
  static const int kMonitorCountFieldNumber = 5;
  ::google::protobuf::int32 monitor_count() const;
  void set_monitor_count(::google::protobuf::int32 value);

  // .eve_public.app.platform.Machine.BatteryDetection battery_detection = 11;
  void clear_battery_detection();
  static const int kBatteryDetectionFieldNumber = 11;
  ::eve_public::app::platform::Machine_BatteryDetection battery_detection() const;
  void set_battery_detection(::eve_public::app::platform::Machine_BatteryDetection value);

  // @@protoc_insertion_point(class_scope:eve_public.app.platform.Machine)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::eve_public::app::platform::Machine_Monitor > monitors_;
  ::google::protobuf::RepeatedPtrField< ::eve_public::app::platform::Machine_GPU > gpus_;
  ::google::protobuf::RepeatedPtrField< ::eve_public::app::platform::Machine_NetworkAdapter > network_adapters_;
  ::google::protobuf::RepeatedPtrField< ::eve_public::app::platform::Machine_HardDrive > hard_drives_;
  ::google::protobuf::internal::ArenaStringPtr model_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  ::eve_public::app::platform::Machine_CPU* cpu_;
  ::eve_public::app::platform::Machine_VM* vm_;
  ::google::protobuf::int64 total_memory_;
  ::google::protobuf::int32 monitor_count_;
  int battery_detection_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5fpublic_2fapp_2fplatform_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Process : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_public.app.platform.Process) */ {
 public:
  Process();
  virtual ~Process();

  Process(const Process& from);

  inline Process& operator=(const Process& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Process(Process&& from) noexcept
    : Process() {
    *this = ::std::move(from);
  }

  inline Process& operator=(Process&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Process& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Process* internal_default_instance() {
    return reinterpret_cast<const Process*>(
               &_Process_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(Process* other);
  friend void swap(Process& a, Process& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Process* New() const final {
    return CreateMaybeMessage<Process>(NULL);
  }

  Process* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Process>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Process& from);
  void MergeFrom(const Process& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Process* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool running_under_rosetta = 1;
  void clear_running_under_rosetta();
  static const int kRunningUnderRosettaFieldNumber = 1;
  bool running_under_rosetta() const;
  void set_running_under_rosetta(bool value);

  // .eve_public.app.platform.Bitness bitness = 2;
  void clear_bitness();
  static const int kBitnessFieldNumber = 2;
  ::eve_public::app::platform::Bitness bitness() const;
  void set_bitness(::eve_public::app::platform::Bitness value);

  // @@protoc_insertion_point(class_scope:eve_public.app.platform.Process)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool running_under_rosetta_;
  int bitness_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5fpublic_2fapp_2fplatform_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Information : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:eve_public.app.platform.Information) */ {
 public:
  Information();
  virtual ~Information();

  Information(const Information& from);

  inline Information& operator=(const Information& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Information(Information&& from) noexcept
    : Information() {
    *this = ::std::move(from);
  }

  inline Information& operator=(Information&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Information& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Information* internal_default_instance() {
    return reinterpret_cast<const Information*>(
               &_Information_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(Information* other);
  friend void swap(Information& a, Information& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Information* New() const final {
    return CreateMaybeMessage<Information>(NULL);
  }

  Information* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Information>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Information& from);
  void MergeFrom(const Information& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Information* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .eve_public.app.platform.SemanticVersion version = 1;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  private:
  const ::eve_public::app::platform::SemanticVersion& _internal_version() const;
  public:
  const ::eve_public::app::platform::SemanticVersion& version() const;
  ::eve_public::app::platform::SemanticVersion* release_version();
  ::eve_public::app::platform::SemanticVersion* mutable_version();
  void set_allocated_version(::eve_public::app::platform::SemanticVersion* version);

  // .google.protobuf.Timestamp timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  private:
  const ::google::protobuf::Timestamp& _internal_timestamp() const;
  public:
  const ::google::protobuf::Timestamp& timestamp() const;
  ::google::protobuf::Timestamp* release_timestamp();
  ::google::protobuf::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* timestamp);

  // .eve_public.app.platform.OS os = 4;
  bool has_os() const;
  void clear_os();
  static const int kOsFieldNumber = 4;
  private:
  const ::eve_public::app::platform::OS& _internal_os() const;
  public:
  const ::eve_public::app::platform::OS& os() const;
  ::eve_public::app::platform::OS* release_os();
  ::eve_public::app::platform::OS* mutable_os();
  void set_allocated_os(::eve_public::app::platform::OS* os);

  // .eve_public.app.platform.Machine machine = 5;
  bool has_machine() const;
  void clear_machine();
  static const int kMachineFieldNumber = 5;
  private:
  const ::eve_public::app::platform::Machine& _internal_machine() const;
  public:
  const ::eve_public::app::platform::Machine& machine() const;
  ::eve_public::app::platform::Machine* release_machine();
  ::eve_public::app::platform::Machine* mutable_machine();
  void set_allocated_machine(::eve_public::app::platform::Machine* machine);

  // .eve_public.app.platform.Process process = 6;
  bool has_process() const;
  void clear_process();
  static const int kProcessFieldNumber = 6;
  private:
  const ::eve_public::app::platform::Process& _internal_process() const;
  public:
  const ::eve_public::app::platform::Process& process() const;
  ::eve_public::app::platform::Process* release_process();
  ::eve_public::app::platform::Process* mutable_process();
  void set_allocated_process(::eve_public::app::platform::Process* process);

  // .eve_public.app.platform.Bitness process_bitness = 3 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_process_bitness();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kProcessBitnessFieldNumber = 3;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::eve_public::app::platform::Bitness process_bitness() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_process_bitness(::eve_public::app::platform::Bitness value);

  // @@protoc_insertion_point(class_scope:eve_public.app.platform.Information)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::eve_public::app::platform::SemanticVersion* version_;
  ::google::protobuf::Timestamp* timestamp_;
  ::eve_public::app::platform::OS* os_;
  ::eve_public::app::platform::Machine* machine_;
  ::eve_public::app::platform::Process* process_;
  int process_bitness_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_eve_5fpublic_2fapp_2fplatform_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SemanticVersion

// uint32 major = 1;
inline void SemanticVersion::clear_major() {
  major_ = 0u;
}
inline ::google::protobuf::uint32 SemanticVersion::major() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.SemanticVersion.major)
  return major_;
}
inline void SemanticVersion::set_major(::google::protobuf::uint32 value) {
  
  major_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.SemanticVersion.major)
}

// uint32 minor = 2;
inline void SemanticVersion::clear_minor() {
  minor_ = 0u;
}
inline ::google::protobuf::uint32 SemanticVersion::minor() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.SemanticVersion.minor)
  return minor_;
}
inline void SemanticVersion::set_minor(::google::protobuf::uint32 value) {
  
  minor_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.SemanticVersion.minor)
}

// uint32 patch = 3;
inline void SemanticVersion::clear_patch() {
  patch_ = 0u;
}
inline ::google::protobuf::uint32 SemanticVersion::patch() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.SemanticVersion.patch)
  return patch_;
}
inline void SemanticVersion::set_patch(::google::protobuf::uint32 value) {
  
  patch_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.SemanticVersion.patch)
}

// string prerelease = 4;
inline void SemanticVersion::clear_prerelease() {
  prerelease_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SemanticVersion::prerelease() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.SemanticVersion.prerelease)
  return prerelease_.GetNoArena();
}
inline void SemanticVersion::set_prerelease(const ::std::string& value) {
  
  prerelease_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_public.app.platform.SemanticVersion.prerelease)
}
#if LANG_CXX11
inline void SemanticVersion::set_prerelease(::std::string&& value) {
  
  prerelease_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_public.app.platform.SemanticVersion.prerelease)
}
#endif
inline void SemanticVersion::set_prerelease(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  prerelease_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_public.app.platform.SemanticVersion.prerelease)
}
inline void SemanticVersion::set_prerelease(const char* value, size_t size) {
  
  prerelease_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_public.app.platform.SemanticVersion.prerelease)
}
inline ::std::string* SemanticVersion::mutable_prerelease() {
  
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.SemanticVersion.prerelease)
  return prerelease_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SemanticVersion::release_prerelease() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.SemanticVersion.prerelease)
  
  return prerelease_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SemanticVersion::set_allocated_prerelease(::std::string* prerelease) {
  if (prerelease != NULL) {
    
  } else {
    
  }
  prerelease_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prerelease);
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.SemanticVersion.prerelease)
}

// string build = 5;
inline void SemanticVersion::clear_build() {
  build_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SemanticVersion::build() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.SemanticVersion.build)
  return build_.GetNoArena();
}
inline void SemanticVersion::set_build(const ::std::string& value) {
  
  build_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_public.app.platform.SemanticVersion.build)
}
#if LANG_CXX11
inline void SemanticVersion::set_build(::std::string&& value) {
  
  build_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_public.app.platform.SemanticVersion.build)
}
#endif
inline void SemanticVersion::set_build(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  build_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_public.app.platform.SemanticVersion.build)
}
inline void SemanticVersion::set_build(const char* value, size_t size) {
  
  build_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_public.app.platform.SemanticVersion.build)
}
inline ::std::string* SemanticVersion::mutable_build() {
  
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.SemanticVersion.build)
  return build_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SemanticVersion::release_build() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.SemanticVersion.build)
  
  return build_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SemanticVersion::set_allocated_build(::std::string* build) {
  if (build != NULL) {
    
  } else {
    
  }
  build_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), build);
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.SemanticVersion.build)
}

// -------------------------------------------------------------------

// OS_GraphicsAPIs

// bool metal_supported = 1;
inline void OS_GraphicsAPIs::clear_metal_supported() {
  metal_supported_ = false;
}
inline bool OS_GraphicsAPIs::metal_supported() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.OS.GraphicsAPIs.metal_supported)
  return metal_supported_;
}
inline void OS_GraphicsAPIs::set_metal_supported(bool value) {
  
  metal_supported_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.OS.GraphicsAPIs.metal_supported)
}

// bool vulkan_supported = 2;
inline void OS_GraphicsAPIs::clear_vulkan_supported() {
  vulkan_supported_ = false;
}
inline bool OS_GraphicsAPIs::vulkan_supported() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.OS.GraphicsAPIs.vulkan_supported)
  return vulkan_supported_;
}
inline void OS_GraphicsAPIs::set_vulkan_supported(bool value) {
  
  vulkan_supported_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.OS.GraphicsAPIs.vulkan_supported)
}

// string vulkan_highest_supported_version = 3;
inline void OS_GraphicsAPIs::clear_vulkan_highest_supported_version() {
  vulkan_highest_supported_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OS_GraphicsAPIs::vulkan_highest_supported_version() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.OS.GraphicsAPIs.vulkan_highest_supported_version)
  return vulkan_highest_supported_version_.GetNoArena();
}
inline void OS_GraphicsAPIs::set_vulkan_highest_supported_version(const ::std::string& value) {
  
  vulkan_highest_supported_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_public.app.platform.OS.GraphicsAPIs.vulkan_highest_supported_version)
}
#if LANG_CXX11
inline void OS_GraphicsAPIs::set_vulkan_highest_supported_version(::std::string&& value) {
  
  vulkan_highest_supported_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_public.app.platform.OS.GraphicsAPIs.vulkan_highest_supported_version)
}
#endif
inline void OS_GraphicsAPIs::set_vulkan_highest_supported_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  vulkan_highest_supported_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_public.app.platform.OS.GraphicsAPIs.vulkan_highest_supported_version)
}
inline void OS_GraphicsAPIs::set_vulkan_highest_supported_version(const char* value, size_t size) {
  
  vulkan_highest_supported_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_public.app.platform.OS.GraphicsAPIs.vulkan_highest_supported_version)
}
inline ::std::string* OS_GraphicsAPIs::mutable_vulkan_highest_supported_version() {
  
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.OS.GraphicsAPIs.vulkan_highest_supported_version)
  return vulkan_highest_supported_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OS_GraphicsAPIs::release_vulkan_highest_supported_version() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.OS.GraphicsAPIs.vulkan_highest_supported_version)
  
  return vulkan_highest_supported_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OS_GraphicsAPIs::set_allocated_vulkan_highest_supported_version(::std::string* vulkan_highest_supported_version) {
  if (vulkan_highest_supported_version != NULL) {
    
  } else {
    
  }
  vulkan_highest_supported_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vulkan_highest_supported_version);
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.OS.GraphicsAPIs.vulkan_highest_supported_version)
}

// string d3d_highest_supported_version = 4;
inline void OS_GraphicsAPIs::clear_d3d_highest_supported_version() {
  d3d_highest_supported_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OS_GraphicsAPIs::d3d_highest_supported_version() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.OS.GraphicsAPIs.d3d_highest_supported_version)
  return d3d_highest_supported_version_.GetNoArena();
}
inline void OS_GraphicsAPIs::set_d3d_highest_supported_version(const ::std::string& value) {
  
  d3d_highest_supported_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_public.app.platform.OS.GraphicsAPIs.d3d_highest_supported_version)
}
#if LANG_CXX11
inline void OS_GraphicsAPIs::set_d3d_highest_supported_version(::std::string&& value) {
  
  d3d_highest_supported_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_public.app.platform.OS.GraphicsAPIs.d3d_highest_supported_version)
}
#endif
inline void OS_GraphicsAPIs::set_d3d_highest_supported_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  d3d_highest_supported_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_public.app.platform.OS.GraphicsAPIs.d3d_highest_supported_version)
}
inline void OS_GraphicsAPIs::set_d3d_highest_supported_version(const char* value, size_t size) {
  
  d3d_highest_supported_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_public.app.platform.OS.GraphicsAPIs.d3d_highest_supported_version)
}
inline ::std::string* OS_GraphicsAPIs::mutable_d3d_highest_supported_version() {
  
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.OS.GraphicsAPIs.d3d_highest_supported_version)
  return d3d_highest_supported_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OS_GraphicsAPIs::release_d3d_highest_supported_version() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.OS.GraphicsAPIs.d3d_highest_supported_version)
  
  return d3d_highest_supported_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OS_GraphicsAPIs::set_allocated_d3d_highest_supported_version(::std::string* d3d_highest_supported_version) {
  if (d3d_highest_supported_version != NULL) {
    
  } else {
    
  }
  d3d_highest_supported_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), d3d_highest_supported_version);
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.OS.GraphicsAPIs.d3d_highest_supported_version)
}

// -------------------------------------------------------------------

// OS_Wine

// string version = 1;
inline void OS_Wine::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OS_Wine::version() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.OS.Wine.version)
  return version_.GetNoArena();
}
inline void OS_Wine::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_public.app.platform.OS.Wine.version)
}
#if LANG_CXX11
inline void OS_Wine::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_public.app.platform.OS.Wine.version)
}
#endif
inline void OS_Wine::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_public.app.platform.OS.Wine.version)
}
inline void OS_Wine::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_public.app.platform.OS.Wine.version)
}
inline ::std::string* OS_Wine::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.OS.Wine.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OS_Wine::release_version() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.OS.Wine.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OS_Wine::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.OS.Wine.version)
}

// string host_os = 2;
inline void OS_Wine::clear_host_os() {
  host_os_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OS_Wine::host_os() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.OS.Wine.host_os)
  return host_os_.GetNoArena();
}
inline void OS_Wine::set_host_os(const ::std::string& value) {
  
  host_os_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_public.app.platform.OS.Wine.host_os)
}
#if LANG_CXX11
inline void OS_Wine::set_host_os(::std::string&& value) {
  
  host_os_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_public.app.platform.OS.Wine.host_os)
}
#endif
inline void OS_Wine::set_host_os(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  host_os_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_public.app.platform.OS.Wine.host_os)
}
inline void OS_Wine::set_host_os(const char* value, size_t size) {
  
  host_os_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_public.app.platform.OS.Wine.host_os)
}
inline ::std::string* OS_Wine::mutable_host_os() {
  
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.OS.Wine.host_os)
  return host_os_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OS_Wine::release_host_os() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.OS.Wine.host_os)
  
  return host_os_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OS_Wine::set_allocated_host_os(::std::string* host_os) {
  if (host_os != NULL) {
    
  } else {
    
  }
  host_os_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host_os);
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.OS.Wine.host_os)
}

// -------------------------------------------------------------------

// OS_StreamingService

// .eve_public.app.platform.OS.StreamingService.Provider provider = 1;
inline void OS_StreamingService::clear_provider() {
  provider_ = 0;
}
inline ::eve_public::app::platform::OS_StreamingService_Provider OS_StreamingService::provider() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.OS.StreamingService.provider)
  return static_cast< ::eve_public::app::platform::OS_StreamingService_Provider >(provider_);
}
inline void OS_StreamingService::set_provider(::eve_public::app::platform::OS_StreamingService_Provider value) {
  
  provider_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.OS.StreamingService.provider)
}

// -------------------------------------------------------------------

// OS

// .eve_public.app.platform.OS.Kind type = 1;
inline void OS::clear_type() {
  type_ = 0;
}
inline ::eve_public::app::platform::OS_Kind OS::type() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.OS.type)
  return static_cast< ::eve_public::app::platform::OS_Kind >(type_);
}
inline void OS::set_type(::eve_public::app::platform::OS_Kind value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.OS.type)
}

// string name = 2;
inline void OS::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OS::name() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.OS.name)
  return name_.GetNoArena();
}
inline void OS::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_public.app.platform.OS.name)
}
#if LANG_CXX11
inline void OS::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_public.app.platform.OS.name)
}
#endif
inline void OS::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_public.app.platform.OS.name)
}
inline void OS::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_public.app.platform.OS.name)
}
inline ::std::string* OS::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.OS.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OS::release_name() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.OS.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OS::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.OS.name)
}

// .eve_public.app.platform.Bitness bitness = 3;
inline void OS::clear_bitness() {
  bitness_ = 0;
}
inline ::eve_public::app::platform::Bitness OS::bitness() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.OS.bitness)
  return static_cast< ::eve_public::app::platform::Bitness >(bitness_);
}
inline void OS::set_bitness(::eve_public::app::platform::Bitness value) {
  
  bitness_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.OS.bitness)
}

// string major_version = 4;
inline void OS::clear_major_version() {
  major_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OS::major_version() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.OS.major_version)
  return major_version_.GetNoArena();
}
inline void OS::set_major_version(const ::std::string& value) {
  
  major_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_public.app.platform.OS.major_version)
}
#if LANG_CXX11
inline void OS::set_major_version(::std::string&& value) {
  
  major_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_public.app.platform.OS.major_version)
}
#endif
inline void OS::set_major_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  major_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_public.app.platform.OS.major_version)
}
inline void OS::set_major_version(const char* value, size_t size) {
  
  major_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_public.app.platform.OS.major_version)
}
inline ::std::string* OS::mutable_major_version() {
  
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.OS.major_version)
  return major_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OS::release_major_version() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.OS.major_version)
  
  return major_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OS::set_allocated_major_version(::std::string* major_version) {
  if (major_version != NULL) {
    
  } else {
    
  }
  major_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), major_version);
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.OS.major_version)
}

// string minor_version = 5;
inline void OS::clear_minor_version() {
  minor_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OS::minor_version() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.OS.minor_version)
  return minor_version_.GetNoArena();
}
inline void OS::set_minor_version(const ::std::string& value) {
  
  minor_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_public.app.platform.OS.minor_version)
}
#if LANG_CXX11
inline void OS::set_minor_version(::std::string&& value) {
  
  minor_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_public.app.platform.OS.minor_version)
}
#endif
inline void OS::set_minor_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  minor_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_public.app.platform.OS.minor_version)
}
inline void OS::set_minor_version(const char* value, size_t size) {
  
  minor_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_public.app.platform.OS.minor_version)
}
inline ::std::string* OS::mutable_minor_version() {
  
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.OS.minor_version)
  return minor_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OS::release_minor_version() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.OS.minor_version)
  
  return minor_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OS::set_allocated_minor_version(::std::string* minor_version) {
  if (minor_version != NULL) {
    
  } else {
    
  }
  minor_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), minor_version);
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.OS.minor_version)
}

// string build_number = 6;
inline void OS::clear_build_number() {
  build_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OS::build_number() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.OS.build_number)
  return build_number_.GetNoArena();
}
inline void OS::set_build_number(const ::std::string& value) {
  
  build_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_public.app.platform.OS.build_number)
}
#if LANG_CXX11
inline void OS::set_build_number(::std::string&& value) {
  
  build_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_public.app.platform.OS.build_number)
}
#endif
inline void OS::set_build_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  build_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_public.app.platform.OS.build_number)
}
inline void OS::set_build_number(const char* value, size_t size) {
  
  build_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_public.app.platform.OS.build_number)
}
inline ::std::string* OS::mutable_build_number() {
  
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.OS.build_number)
  return build_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OS::release_build_number() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.OS.build_number)
  
  return build_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OS::set_allocated_build_number(::std::string* build_number) {
  if (build_number != NULL) {
    
  } else {
    
  }
  build_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), build_number);
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.OS.build_number)
}

// string kernel_version = 7;
inline void OS::clear_kernel_version() {
  kernel_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OS::kernel_version() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.OS.kernel_version)
  return kernel_version_.GetNoArena();
}
inline void OS::set_kernel_version(const ::std::string& value) {
  
  kernel_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_public.app.platform.OS.kernel_version)
}
#if LANG_CXX11
inline void OS::set_kernel_version(::std::string&& value) {
  
  kernel_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_public.app.platform.OS.kernel_version)
}
#endif
inline void OS::set_kernel_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  kernel_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_public.app.platform.OS.kernel_version)
}
inline void OS::set_kernel_version(const char* value, size_t size) {
  
  kernel_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_public.app.platform.OS.kernel_version)
}
inline ::std::string* OS::mutable_kernel_version() {
  
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.OS.kernel_version)
  return kernel_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OS::release_kernel_version() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.OS.kernel_version)
  
  return kernel_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OS::set_allocated_kernel_version(::std::string* kernel_version) {
  if (kernel_version != NULL) {
    
  } else {
    
  }
  kernel_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), kernel_version);
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.OS.kernel_version)
}

// string username = 8;
inline void OS::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OS::username() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.OS.username)
  return username_.GetNoArena();
}
inline void OS::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_public.app.platform.OS.username)
}
#if LANG_CXX11
inline void OS::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_public.app.platform.OS.username)
}
#endif
inline void OS::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_public.app.platform.OS.username)
}
inline void OS::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_public.app.platform.OS.username)
}
inline ::std::string* OS::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.OS.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OS::release_username() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.OS.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OS::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.OS.username)
}

// string user_locale = 9;
inline void OS::clear_user_locale() {
  user_locale_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OS::user_locale() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.OS.user_locale)
  return user_locale_.GetNoArena();
}
inline void OS::set_user_locale(const ::std::string& value) {
  
  user_locale_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_public.app.platform.OS.user_locale)
}
#if LANG_CXX11
inline void OS::set_user_locale(::std::string&& value) {
  
  user_locale_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_public.app.platform.OS.user_locale)
}
#endif
inline void OS::set_user_locale(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  user_locale_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_public.app.platform.OS.user_locale)
}
inline void OS::set_user_locale(const char* value, size_t size) {
  
  user_locale_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_public.app.platform.OS.user_locale)
}
inline ::std::string* OS::mutable_user_locale() {
  
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.OS.user_locale)
  return user_locale_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OS::release_user_locale() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.OS.user_locale)
  
  return user_locale_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OS::set_allocated_user_locale(::std::string* user_locale) {
  if (user_locale != NULL) {
    
  } else {
    
  }
  user_locale_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_locale);
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.OS.user_locale)
}

// bool is_remote_session = 10;
inline void OS::clear_is_remote_session() {
  is_remote_session_ = false;
}
inline bool OS::is_remote_session() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.OS.is_remote_session)
  return is_remote_session_;
}
inline void OS::set_is_remote_session(bool value) {
  
  is_remote_session_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.OS.is_remote_session)
}

// .eve_public.app.platform.OS.GraphicsAPIs graphics_apis = 11;
inline bool OS::has_graphics_apis() const {
  return this != internal_default_instance() && graphics_apis_ != NULL;
}
inline void OS::clear_graphics_apis() {
  if (GetArenaNoVirtual() == NULL && graphics_apis_ != NULL) {
    delete graphics_apis_;
  }
  graphics_apis_ = NULL;
}
inline const ::eve_public::app::platform::OS_GraphicsAPIs& OS::_internal_graphics_apis() const {
  return *graphics_apis_;
}
inline const ::eve_public::app::platform::OS_GraphicsAPIs& OS::graphics_apis() const {
  const ::eve_public::app::platform::OS_GraphicsAPIs* p = graphics_apis_;
  // @@protoc_insertion_point(field_get:eve_public.app.platform.OS.graphics_apis)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_public::app::platform::OS_GraphicsAPIs*>(
      &::eve_public::app::platform::_OS_GraphicsAPIs_default_instance_);
}
inline ::eve_public::app::platform::OS_GraphicsAPIs* OS::release_graphics_apis() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.OS.graphics_apis)
  
  ::eve_public::app::platform::OS_GraphicsAPIs* temp = graphics_apis_;
  graphics_apis_ = NULL;
  return temp;
}
inline ::eve_public::app::platform::OS_GraphicsAPIs* OS::mutable_graphics_apis() {
  
  if (graphics_apis_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_public::app::platform::OS_GraphicsAPIs>(GetArenaNoVirtual());
    graphics_apis_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.OS.graphics_apis)
  return graphics_apis_;
}
inline void OS::set_allocated_graphics_apis(::eve_public::app::platform::OS_GraphicsAPIs* graphics_apis) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete graphics_apis_;
  }
  if (graphics_apis) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      graphics_apis = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, graphics_apis, submessage_arena);
    }
    
  } else {
    
  }
  graphics_apis_ = graphics_apis;
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.OS.graphics_apis)
}

// .eve_public.app.platform.OS.Wine wine = 12;
inline bool OS::has_wine() const {
  return this != internal_default_instance() && wine_ != NULL;
}
inline void OS::clear_wine() {
  if (GetArenaNoVirtual() == NULL && wine_ != NULL) {
    delete wine_;
  }
  wine_ = NULL;
}
inline const ::eve_public::app::platform::OS_Wine& OS::_internal_wine() const {
  return *wine_;
}
inline const ::eve_public::app::platform::OS_Wine& OS::wine() const {
  const ::eve_public::app::platform::OS_Wine* p = wine_;
  // @@protoc_insertion_point(field_get:eve_public.app.platform.OS.wine)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_public::app::platform::OS_Wine*>(
      &::eve_public::app::platform::_OS_Wine_default_instance_);
}
inline ::eve_public::app::platform::OS_Wine* OS::release_wine() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.OS.wine)
  
  ::eve_public::app::platform::OS_Wine* temp = wine_;
  wine_ = NULL;
  return temp;
}
inline ::eve_public::app::platform::OS_Wine* OS::mutable_wine() {
  
  if (wine_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_public::app::platform::OS_Wine>(GetArenaNoVirtual());
    wine_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.OS.wine)
  return wine_;
}
inline void OS::set_allocated_wine(::eve_public::app::platform::OS_Wine* wine) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete wine_;
  }
  if (wine) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      wine = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, wine, submessage_arena);
    }
    
  } else {
    
  }
  wine_ = wine;
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.OS.wine)
}

// .eve_public.app.platform.OS.StreamingService streaming_service = 13;
inline bool OS::has_streaming_service() const {
  return this != internal_default_instance() && streaming_service_ != NULL;
}
inline void OS::clear_streaming_service() {
  if (GetArenaNoVirtual() == NULL && streaming_service_ != NULL) {
    delete streaming_service_;
  }
  streaming_service_ = NULL;
}
inline const ::eve_public::app::platform::OS_StreamingService& OS::_internal_streaming_service() const {
  return *streaming_service_;
}
inline const ::eve_public::app::platform::OS_StreamingService& OS::streaming_service() const {
  const ::eve_public::app::platform::OS_StreamingService* p = streaming_service_;
  // @@protoc_insertion_point(field_get:eve_public.app.platform.OS.streaming_service)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_public::app::platform::OS_StreamingService*>(
      &::eve_public::app::platform::_OS_StreamingService_default_instance_);
}
inline ::eve_public::app::platform::OS_StreamingService* OS::release_streaming_service() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.OS.streaming_service)
  
  ::eve_public::app::platform::OS_StreamingService* temp = streaming_service_;
  streaming_service_ = NULL;
  return temp;
}
inline ::eve_public::app::platform::OS_StreamingService* OS::mutable_streaming_service() {
  
  if (streaming_service_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_public::app::platform::OS_StreamingService>(GetArenaNoVirtual());
    streaming_service_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.OS.streaming_service)
  return streaming_service_;
}
inline void OS::set_allocated_streaming_service(::eve_public::app::platform::OS_StreamingService* streaming_service) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete streaming_service_;
  }
  if (streaming_service) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      streaming_service = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, streaming_service, submessage_arena);
    }
    
  } else {
    
  }
  streaming_service_ = streaming_service;
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.OS.streaming_service)
}

// -------------------------------------------------------------------

// Machine_CPU

// .eve_public.app.platform.Bitness bitness = 1;
inline void Machine_CPU::clear_bitness() {
  bitness_ = 0;
}
inline ::eve_public::app::platform::Bitness Machine_CPU::bitness() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.CPU.bitness)
  return static_cast< ::eve_public::app::platform::Bitness >(bitness_);
}
inline void Machine_CPU::set_bitness(::eve_public::app::platform::Bitness value) {
  
  bitness_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.CPU.bitness)
}

// int32 logical_core_count = 2;
inline void Machine_CPU::clear_logical_core_count() {
  logical_core_count_ = 0;
}
inline ::google::protobuf::int32 Machine_CPU::logical_core_count() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.CPU.logical_core_count)
  return logical_core_count_;
}
inline void Machine_CPU::set_logical_core_count(::google::protobuf::int32 value) {
  
  logical_core_count_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.CPU.logical_core_count)
}

// string brand = 3;
inline void Machine_CPU::clear_brand() {
  brand_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Machine_CPU::brand() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.CPU.brand)
  return brand_.GetNoArena();
}
inline void Machine_CPU::set_brand(const ::std::string& value) {
  
  brand_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.CPU.brand)
}
#if LANG_CXX11
inline void Machine_CPU::set_brand(::std::string&& value) {
  
  brand_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_public.app.platform.Machine.CPU.brand)
}
#endif
inline void Machine_CPU::set_brand(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  brand_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_public.app.platform.Machine.CPU.brand)
}
inline void Machine_CPU::set_brand(const char* value, size_t size) {
  
  brand_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_public.app.platform.Machine.CPU.brand)
}
inline ::std::string* Machine_CPU::mutable_brand() {
  
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.Machine.CPU.brand)
  return brand_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Machine_CPU::release_brand() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.Machine.CPU.brand)
  
  return brand_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Machine_CPU::set_allocated_brand(::std::string* brand) {
  if (brand != NULL) {
    
  } else {
    
  }
  brand_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), brand);
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.Machine.CPU.brand)
}

// string vendor = 4;
inline void Machine_CPU::clear_vendor() {
  vendor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Machine_CPU::vendor() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.CPU.vendor)
  return vendor_.GetNoArena();
}
inline void Machine_CPU::set_vendor(const ::std::string& value) {
  
  vendor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.CPU.vendor)
}
#if LANG_CXX11
inline void Machine_CPU::set_vendor(::std::string&& value) {
  
  vendor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_public.app.platform.Machine.CPU.vendor)
}
#endif
inline void Machine_CPU::set_vendor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  vendor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_public.app.platform.Machine.CPU.vendor)
}
inline void Machine_CPU::set_vendor(const char* value, size_t size) {
  
  vendor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_public.app.platform.Machine.CPU.vendor)
}
inline ::std::string* Machine_CPU::mutable_vendor() {
  
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.Machine.CPU.vendor)
  return vendor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Machine_CPU::release_vendor() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.Machine.CPU.vendor)
  
  return vendor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Machine_CPU::set_allocated_vendor(::std::string* vendor) {
  if (vendor != NULL) {
    
  } else {
    
  }
  vendor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vendor);
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.Machine.CPU.vendor)
}

// int32 model = 5;
inline void Machine_CPU::clear_model() {
  model_ = 0;
}
inline ::google::protobuf::int32 Machine_CPU::model() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.CPU.model)
  return model_;
}
inline void Machine_CPU::set_model(::google::protobuf::int32 value) {
  
  model_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.CPU.model)
}

// int32 stepping = 6;
inline void Machine_CPU::clear_stepping() {
  stepping_ = 0;
}
inline ::google::protobuf::int32 Machine_CPU::stepping() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.CPU.stepping)
  return stepping_;
}
inline void Machine_CPU::set_stepping(::google::protobuf::int32 value) {
  
  stepping_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.CPU.stepping)
}

// .eve_public.app.platform.Machine.CPU.Architecture architecture = 7;
inline void Machine_CPU::clear_architecture() {
  architecture_ = 0;
}
inline ::eve_public::app::platform::Machine_CPU_Architecture Machine_CPU::architecture() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.CPU.architecture)
  return static_cast< ::eve_public::app::platform::Machine_CPU_Architecture >(architecture_);
}
inline void Machine_CPU::set_architecture(::eve_public::app::platform::Machine_CPU_Architecture value) {
  
  architecture_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.CPU.architecture)
}

// repeated string extensions = 8;
inline int Machine_CPU::extensions_size() const {
  return extensions_.size();
}
inline void Machine_CPU::clear_extensions() {
  extensions_.Clear();
}
inline const ::std::string& Machine_CPU::extensions(int index) const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.CPU.extensions)
  return extensions_.Get(index);
}
inline ::std::string* Machine_CPU::mutable_extensions(int index) {
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.Machine.CPU.extensions)
  return extensions_.Mutable(index);
}
inline void Machine_CPU::set_extensions(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.CPU.extensions)
  extensions_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Machine_CPU::set_extensions(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.CPU.extensions)
  extensions_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Machine_CPU::set_extensions(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  extensions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:eve_public.app.platform.Machine.CPU.extensions)
}
inline void Machine_CPU::set_extensions(int index, const char* value, size_t size) {
  extensions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:eve_public.app.platform.Machine.CPU.extensions)
}
inline ::std::string* Machine_CPU::add_extensions() {
  // @@protoc_insertion_point(field_add_mutable:eve_public.app.platform.Machine.CPU.extensions)
  return extensions_.Add();
}
inline void Machine_CPU::add_extensions(const ::std::string& value) {
  extensions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:eve_public.app.platform.Machine.CPU.extensions)
}
#if LANG_CXX11
inline void Machine_CPU::add_extensions(::std::string&& value) {
  extensions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:eve_public.app.platform.Machine.CPU.extensions)
}
#endif
inline void Machine_CPU::add_extensions(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  extensions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:eve_public.app.platform.Machine.CPU.extensions)
}
inline void Machine_CPU::add_extensions(const char* value, size_t size) {
  extensions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:eve_public.app.platform.Machine.CPU.extensions)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Machine_CPU::extensions() const {
  // @@protoc_insertion_point(field_list:eve_public.app.platform.Machine.CPU.extensions)
  return extensions_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Machine_CPU::mutable_extensions() {
  // @@protoc_insertion_point(field_mutable_list:eve_public.app.platform.Machine.CPU.extensions)
  return &extensions_;
}

// uint32 frequency = 9;
inline void Machine_CPU::clear_frequency() {
  frequency_ = 0u;
}
inline ::google::protobuf::uint32 Machine_CPU::frequency() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.CPU.frequency)
  return frequency_;
}
inline void Machine_CPU::set_frequency(::google::protobuf::uint32 value) {
  
  frequency_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.CPU.frequency)
}

// -------------------------------------------------------------------

// Machine_VM

// bool is_suspected_vm = 1;
inline void Machine_VM::clear_is_suspected_vm() {
  is_suspected_vm_ = false;
}
inline bool Machine_VM::is_suspected_vm() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.VM.is_suspected_vm)
  return is_suspected_vm_;
}
inline void Machine_VM::set_is_suspected_vm(bool value) {
  
  is_suspected_vm_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.VM.is_suspected_vm)
}

// bool has_hypervisor_bit = 2;
inline void Machine_VM::clear_has_hypervisor_bit() {
  has_hypervisor_bit_ = false;
}
inline bool Machine_VM::has_hypervisor_bit() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.VM.has_hypervisor_bit)
  return has_hypervisor_bit_;
}
inline void Machine_VM::set_has_hypervisor_bit(bool value) {
  
  has_hypervisor_bit_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.VM.has_hypervisor_bit)
}

// string hypervisor_name = 3;
inline void Machine_VM::clear_hypervisor_name() {
  hypervisor_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Machine_VM::hypervisor_name() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.VM.hypervisor_name)
  return hypervisor_name_.GetNoArena();
}
inline void Machine_VM::set_hypervisor_name(const ::std::string& value) {
  
  hypervisor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.VM.hypervisor_name)
}
#if LANG_CXX11
inline void Machine_VM::set_hypervisor_name(::std::string&& value) {
  
  hypervisor_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_public.app.platform.Machine.VM.hypervisor_name)
}
#endif
inline void Machine_VM::set_hypervisor_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hypervisor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_public.app.platform.Machine.VM.hypervisor_name)
}
inline void Machine_VM::set_hypervisor_name(const char* value, size_t size) {
  
  hypervisor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_public.app.platform.Machine.VM.hypervisor_name)
}
inline ::std::string* Machine_VM::mutable_hypervisor_name() {
  
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.Machine.VM.hypervisor_name)
  return hypervisor_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Machine_VM::release_hypervisor_name() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.Machine.VM.hypervisor_name)
  
  return hypervisor_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Machine_VM::set_allocated_hypervisor_name(::std::string* hypervisor_name) {
  if (hypervisor_name != NULL) {
    
  } else {
    
  }
  hypervisor_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hypervisor_name);
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.Machine.VM.hypervisor_name)
}

// bool is_hypervisor_guest_os = 4;
inline void Machine_VM::clear_is_hypervisor_guest_os() {
  is_hypervisor_guest_os_ = false;
}
inline bool Machine_VM::is_hypervisor_guest_os() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.VM.is_hypervisor_guest_os)
  return is_hypervisor_guest_os_;
}
inline void Machine_VM::set_is_hypervisor_guest_os(bool value) {
  
  is_hypervisor_guest_os_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.VM.is_hypervisor_guest_os)
}

// bool has_vm_execution_timing = 5;
inline void Machine_VM::clear_has_vm_execution_timing() {
  has_vm_execution_timing_ = false;
}
inline bool Machine_VM::has_vm_execution_timing() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.VM.has_vm_execution_timing)
  return has_vm_execution_timing_;
}
inline void Machine_VM::set_has_vm_execution_timing(bool value) {
  
  has_vm_execution_timing_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.VM.has_vm_execution_timing)
}

// -------------------------------------------------------------------

// Machine_Monitor

// string name = 1;
inline void Machine_Monitor::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Machine_Monitor::name() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.Monitor.name)
  return name_.GetNoArena();
}
inline void Machine_Monitor::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.Monitor.name)
}
#if LANG_CXX11
inline void Machine_Monitor::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_public.app.platform.Machine.Monitor.name)
}
#endif
inline void Machine_Monitor::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_public.app.platform.Machine.Monitor.name)
}
inline void Machine_Monitor::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_public.app.platform.Machine.Monitor.name)
}
inline ::std::string* Machine_Monitor::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.Machine.Monitor.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Machine_Monitor::release_name() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.Machine.Monitor.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Machine_Monitor::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.Machine.Monitor.name)
}

// int32 horizontal_resolution = 2;
inline void Machine_Monitor::clear_horizontal_resolution() {
  horizontal_resolution_ = 0;
}
inline ::google::protobuf::int32 Machine_Monitor::horizontal_resolution() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.Monitor.horizontal_resolution)
  return horizontal_resolution_;
}
inline void Machine_Monitor::set_horizontal_resolution(::google::protobuf::int32 value) {
  
  horizontal_resolution_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.Monitor.horizontal_resolution)
}

// int32 vertical_resolution = 3;
inline void Machine_Monitor::clear_vertical_resolution() {
  vertical_resolution_ = 0;
}
inline ::google::protobuf::int32 Machine_Monitor::vertical_resolution() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.Monitor.vertical_resolution)
  return vertical_resolution_;
}
inline void Machine_Monitor::set_vertical_resolution(::google::protobuf::int32 value) {
  
  vertical_resolution_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.Monitor.vertical_resolution)
}

// int32 bits_per_color = 4;
inline void Machine_Monitor::clear_bits_per_color() {
  bits_per_color_ = 0;
}
inline ::google::protobuf::int32 Machine_Monitor::bits_per_color() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.Monitor.bits_per_color)
  return bits_per_color_;
}
inline void Machine_Monitor::set_bits_per_color(::google::protobuf::int32 value) {
  
  bits_per_color_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.Monitor.bits_per_color)
}

// int32 refresh_rate = 5;
inline void Machine_Monitor::clear_refresh_rate() {
  refresh_rate_ = 0;
}
inline ::google::protobuf::int32 Machine_Monitor::refresh_rate() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.Monitor.refresh_rate)
  return refresh_rate_;
}
inline void Machine_Monitor::set_refresh_rate(::google::protobuf::int32 value) {
  
  refresh_rate_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.Monitor.refresh_rate)
}

// int32 dpi_scaling_percent = 6;
inline void Machine_Monitor::clear_dpi_scaling_percent() {
  dpi_scaling_percent_ = 0;
}
inline ::google::protobuf::int32 Machine_Monitor::dpi_scaling_percent() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.Monitor.dpi_scaling_percent)
  return dpi_scaling_percent_;
}
inline void Machine_Monitor::set_dpi_scaling_percent(::google::protobuf::int32 value) {
  
  dpi_scaling_percent_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.Monitor.dpi_scaling_percent)
}

// -------------------------------------------------------------------

// Machine_GPU_Driver

// string date = 1;
inline void Machine_GPU_Driver::clear_date() {
  date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Machine_GPU_Driver::date() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.GPU.Driver.date)
  return date_.GetNoArena();
}
inline void Machine_GPU_Driver::set_date(const ::std::string& value) {
  
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.GPU.Driver.date)
}
#if LANG_CXX11
inline void Machine_GPU_Driver::set_date(::std::string&& value) {
  
  date_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_public.app.platform.Machine.GPU.Driver.date)
}
#endif
inline void Machine_GPU_Driver::set_date(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_public.app.platform.Machine.GPU.Driver.date)
}
inline void Machine_GPU_Driver::set_date(const char* value, size_t size) {
  
  date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_public.app.platform.Machine.GPU.Driver.date)
}
inline ::std::string* Machine_GPU_Driver::mutable_date() {
  
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.Machine.GPU.Driver.date)
  return date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Machine_GPU_Driver::release_date() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.Machine.GPU.Driver.date)
  
  return date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Machine_GPU_Driver::set_allocated_date(::std::string* date) {
  if (date != NULL) {
    
  } else {
    
  }
  date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), date);
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.Machine.GPU.Driver.date)
}

// string vendor = 2;
inline void Machine_GPU_Driver::clear_vendor() {
  vendor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Machine_GPU_Driver::vendor() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.GPU.Driver.vendor)
  return vendor_.GetNoArena();
}
inline void Machine_GPU_Driver::set_vendor(const ::std::string& value) {
  
  vendor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.GPU.Driver.vendor)
}
#if LANG_CXX11
inline void Machine_GPU_Driver::set_vendor(::std::string&& value) {
  
  vendor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_public.app.platform.Machine.GPU.Driver.vendor)
}
#endif
inline void Machine_GPU_Driver::set_vendor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  vendor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_public.app.platform.Machine.GPU.Driver.vendor)
}
inline void Machine_GPU_Driver::set_vendor(const char* value, size_t size) {
  
  vendor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_public.app.platform.Machine.GPU.Driver.vendor)
}
inline ::std::string* Machine_GPU_Driver::mutable_vendor() {
  
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.Machine.GPU.Driver.vendor)
  return vendor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Machine_GPU_Driver::release_vendor() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.Machine.GPU.Driver.vendor)
  
  return vendor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Machine_GPU_Driver::set_allocated_vendor(::std::string* vendor) {
  if (vendor != NULL) {
    
  } else {
    
  }
  vendor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vendor);
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.Machine.GPU.Driver.vendor)
}

// string version = 3;
inline void Machine_GPU_Driver::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Machine_GPU_Driver::version() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.GPU.Driver.version)
  return version_.GetNoArena();
}
inline void Machine_GPU_Driver::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.GPU.Driver.version)
}
#if LANG_CXX11
inline void Machine_GPU_Driver::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_public.app.platform.Machine.GPU.Driver.version)
}
#endif
inline void Machine_GPU_Driver::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_public.app.platform.Machine.GPU.Driver.version)
}
inline void Machine_GPU_Driver::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_public.app.platform.Machine.GPU.Driver.version)
}
inline ::std::string* Machine_GPU_Driver::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.Machine.GPU.Driver.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Machine_GPU_Driver::release_version() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.Machine.GPU.Driver.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Machine_GPU_Driver::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.Machine.GPU.Driver.version)
}

// -------------------------------------------------------------------

// Machine_GPU

// string description = 1;
inline void Machine_GPU::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Machine_GPU::description() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.GPU.description)
  return description_.GetNoArena();
}
inline void Machine_GPU::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.GPU.description)
}
#if LANG_CXX11
inline void Machine_GPU::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_public.app.platform.Machine.GPU.description)
}
#endif
inline void Machine_GPU::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_public.app.platform.Machine.GPU.description)
}
inline void Machine_GPU::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_public.app.platform.Machine.GPU.description)
}
inline ::std::string* Machine_GPU::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.Machine.GPU.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Machine_GPU::release_description() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.Machine.GPU.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Machine_GPU::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.Machine.GPU.description)
}

// int32 vendor_id = 2;
inline void Machine_GPU::clear_vendor_id() {
  vendor_id_ = 0;
}
inline ::google::protobuf::int32 Machine_GPU::vendor_id() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.GPU.vendor_id)
  return vendor_id_;
}
inline void Machine_GPU::set_vendor_id(::google::protobuf::int32 value) {
  
  vendor_id_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.GPU.vendor_id)
}

// int32 device_id = 3;
inline void Machine_GPU::clear_device_id() {
  device_id_ = 0;
}
inline ::google::protobuf::int32 Machine_GPU::device_id() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.GPU.device_id)
  return device_id_;
}
inline void Machine_GPU::set_device_id(::google::protobuf::int32 value) {
  
  device_id_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.GPU.device_id)
}

// int32 revision = 4;
inline void Machine_GPU::clear_revision() {
  revision_ = 0;
}
inline ::google::protobuf::int32 Machine_GPU::revision() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.GPU.revision)
  return revision_;
}
inline void Machine_GPU::set_revision(::google::protobuf::int32 value) {
  
  revision_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.GPU.revision)
}

// int64 video_memory = 5;
inline void Machine_GPU::clear_video_memory() {
  video_memory_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Machine_GPU::video_memory() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.GPU.video_memory)
  return video_memory_;
}
inline void Machine_GPU::set_video_memory(::google::protobuf::int64 value) {
  
  video_memory_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.GPU.video_memory)
}

// .eve_public.app.platform.Machine.GPU.Driver driver = 6;
inline bool Machine_GPU::has_driver() const {
  return this != internal_default_instance() && driver_ != NULL;
}
inline void Machine_GPU::clear_driver() {
  if (GetArenaNoVirtual() == NULL && driver_ != NULL) {
    delete driver_;
  }
  driver_ = NULL;
}
inline const ::eve_public::app::platform::Machine_GPU_Driver& Machine_GPU::_internal_driver() const {
  return *driver_;
}
inline const ::eve_public::app::platform::Machine_GPU_Driver& Machine_GPU::driver() const {
  const ::eve_public::app::platform::Machine_GPU_Driver* p = driver_;
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.GPU.driver)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_public::app::platform::Machine_GPU_Driver*>(
      &::eve_public::app::platform::_Machine_GPU_Driver_default_instance_);
}
inline ::eve_public::app::platform::Machine_GPU_Driver* Machine_GPU::release_driver() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.Machine.GPU.driver)
  
  ::eve_public::app::platform::Machine_GPU_Driver* temp = driver_;
  driver_ = NULL;
  return temp;
}
inline ::eve_public::app::platform::Machine_GPU_Driver* Machine_GPU::mutable_driver() {
  
  if (driver_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_public::app::platform::Machine_GPU_Driver>(GetArenaNoVirtual());
    driver_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.Machine.GPU.driver)
  return driver_;
}
inline void Machine_GPU::set_allocated_driver(::eve_public::app::platform::Machine_GPU_Driver* driver) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete driver_;
  }
  if (driver) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      driver = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, driver, submessage_arena);
    }
    
  } else {
    
  }
  driver_ = driver;
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.Machine.GPU.driver)
}

// uint32 core_count = 7;
inline void Machine_GPU::clear_core_count() {
  core_count_ = 0u;
}
inline ::google::protobuf::uint32 Machine_GPU::core_count() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.GPU.core_count)
  return core_count_;
}
inline void Machine_GPU::set_core_count(::google::protobuf::uint32 value) {
  
  core_count_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.GPU.core_count)
}

// -------------------------------------------------------------------

// Machine_NetworkAdapter

// string name = 1;
inline void Machine_NetworkAdapter::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Machine_NetworkAdapter::name() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.NetworkAdapter.name)
  return name_.GetNoArena();
}
inline void Machine_NetworkAdapter::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.NetworkAdapter.name)
}
#if LANG_CXX11
inline void Machine_NetworkAdapter::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_public.app.platform.Machine.NetworkAdapter.name)
}
#endif
inline void Machine_NetworkAdapter::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_public.app.platform.Machine.NetworkAdapter.name)
}
inline void Machine_NetworkAdapter::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_public.app.platform.Machine.NetworkAdapter.name)
}
inline ::std::string* Machine_NetworkAdapter::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.Machine.NetworkAdapter.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Machine_NetworkAdapter::release_name() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.Machine.NetworkAdapter.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Machine_NetworkAdapter::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.Machine.NetworkAdapter.name)
}

// bytes mac_address = 2;
inline void Machine_NetworkAdapter::clear_mac_address() {
  mac_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Machine_NetworkAdapter::mac_address() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.NetworkAdapter.mac_address)
  return mac_address_.GetNoArena();
}
inline void Machine_NetworkAdapter::set_mac_address(const ::std::string& value) {
  
  mac_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.NetworkAdapter.mac_address)
}
#if LANG_CXX11
inline void Machine_NetworkAdapter::set_mac_address(::std::string&& value) {
  
  mac_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_public.app.platform.Machine.NetworkAdapter.mac_address)
}
#endif
inline void Machine_NetworkAdapter::set_mac_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  mac_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_public.app.platform.Machine.NetworkAdapter.mac_address)
}
inline void Machine_NetworkAdapter::set_mac_address(const void* value, size_t size) {
  
  mac_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_public.app.platform.Machine.NetworkAdapter.mac_address)
}
inline ::std::string* Machine_NetworkAdapter::mutable_mac_address() {
  
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.Machine.NetworkAdapter.mac_address)
  return mac_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Machine_NetworkAdapter::release_mac_address() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.Machine.NetworkAdapter.mac_address)
  
  return mac_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Machine_NetworkAdapter::set_allocated_mac_address(::std::string* mac_address) {
  if (mac_address != NULL) {
    
  } else {
    
  }
  mac_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mac_address);
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.Machine.NetworkAdapter.mac_address)
}

// bytes uuid = 3;
inline void Machine_NetworkAdapter::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Machine_NetworkAdapter::uuid() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.NetworkAdapter.uuid)
  return uuid_.GetNoArena();
}
inline void Machine_NetworkAdapter::set_uuid(const ::std::string& value) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.NetworkAdapter.uuid)
}
#if LANG_CXX11
inline void Machine_NetworkAdapter::set_uuid(::std::string&& value) {
  
  uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_public.app.platform.Machine.NetworkAdapter.uuid)
}
#endif
inline void Machine_NetworkAdapter::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_public.app.platform.Machine.NetworkAdapter.uuid)
}
inline void Machine_NetworkAdapter::set_uuid(const void* value, size_t size) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_public.app.platform.Machine.NetworkAdapter.uuid)
}
inline ::std::string* Machine_NetworkAdapter::mutable_uuid() {
  
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.Machine.NetworkAdapter.uuid)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Machine_NetworkAdapter::release_uuid() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.Machine.NetworkAdapter.uuid)
  
  return uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Machine_NetworkAdapter::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    
  } else {
    
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.Machine.NetworkAdapter.uuid)
}

// -------------------------------------------------------------------

// Machine_HardDrive

// string name = 1;
inline void Machine_HardDrive::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Machine_HardDrive::name() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.HardDrive.name)
  return name_.GetNoArena();
}
inline void Machine_HardDrive::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.HardDrive.name)
}
#if LANG_CXX11
inline void Machine_HardDrive::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_public.app.platform.Machine.HardDrive.name)
}
#endif
inline void Machine_HardDrive::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_public.app.platform.Machine.HardDrive.name)
}
inline void Machine_HardDrive::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_public.app.platform.Machine.HardDrive.name)
}
inline ::std::string* Machine_HardDrive::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.Machine.HardDrive.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Machine_HardDrive::release_name() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.Machine.HardDrive.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Machine_HardDrive::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.Machine.HardDrive.name)
}

// .eve_public.app.platform.Machine.HardDrive.DriveType drive_type = 2;
inline void Machine_HardDrive::clear_drive_type() {
  drive_type_ = 0;
}
inline ::eve_public::app::platform::Machine_HardDrive_DriveType Machine_HardDrive::drive_type() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.HardDrive.drive_type)
  return static_cast< ::eve_public::app::platform::Machine_HardDrive_DriveType >(drive_type_);
}
inline void Machine_HardDrive::set_drive_type(::eve_public::app::platform::Machine_HardDrive_DriveType value) {
  
  drive_type_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.HardDrive.drive_type)
}

// uint64 size = 3;
inline void Machine_HardDrive::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Machine_HardDrive::size() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.HardDrive.size)
  return size_;
}
inline void Machine_HardDrive::set_size(::google::protobuf::uint64 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.HardDrive.size)
}

// -------------------------------------------------------------------

// Machine

// string model = 1;
inline void Machine::clear_model() {
  model_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Machine::model() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.model)
  return model_.GetNoArena();
}
inline void Machine::set_model(const ::std::string& value) {
  
  model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.model)
}
#if LANG_CXX11
inline void Machine::set_model(::std::string&& value) {
  
  model_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_public.app.platform.Machine.model)
}
#endif
inline void Machine::set_model(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_public.app.platform.Machine.model)
}
inline void Machine::set_model(const char* value, size_t size) {
  
  model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_public.app.platform.Machine.model)
}
inline ::std::string* Machine::mutable_model() {
  
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.Machine.model)
  return model_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Machine::release_model() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.Machine.model)
  
  return model_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Machine::set_allocated_model(::std::string* model) {
  if (model != NULL) {
    
  } else {
    
  }
  model_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model);
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.Machine.model)
}

// string name = 2;
inline void Machine::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Machine::name() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.name)
  return name_.GetNoArena();
}
inline void Machine::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.name)
}
#if LANG_CXX11
inline void Machine::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_public.app.platform.Machine.name)
}
#endif
inline void Machine::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_public.app.platform.Machine.name)
}
inline void Machine::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_public.app.platform.Machine.name)
}
inline ::std::string* Machine::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.Machine.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Machine::release_name() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.Machine.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Machine::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.Machine.name)
}

// bytes uuid = 3;
inline void Machine::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Machine::uuid() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.uuid)
  return uuid_.GetNoArena();
}
inline void Machine::set_uuid(const ::std::string& value) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.uuid)
}
#if LANG_CXX11
inline void Machine::set_uuid(::std::string&& value) {
  
  uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:eve_public.app.platform.Machine.uuid)
}
#endif
inline void Machine::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:eve_public.app.platform.Machine.uuid)
}
inline void Machine::set_uuid(const void* value, size_t size) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:eve_public.app.platform.Machine.uuid)
}
inline ::std::string* Machine::mutable_uuid() {
  
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.Machine.uuid)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Machine::release_uuid() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.Machine.uuid)
  
  return uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Machine::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    
  } else {
    
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.Machine.uuid)
}

// int64 total_memory = 4;
inline void Machine::clear_total_memory() {
  total_memory_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Machine::total_memory() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.total_memory)
  return total_memory_;
}
inline void Machine::set_total_memory(::google::protobuf::int64 value) {
  
  total_memory_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.total_memory)
}

// int32 monitor_count = 5;
inline void Machine::clear_monitor_count() {
  monitor_count_ = 0;
}
inline ::google::protobuf::int32 Machine::monitor_count() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.monitor_count)
  return monitor_count_;
}
inline void Machine::set_monitor_count(::google::protobuf::int32 value) {
  
  monitor_count_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.monitor_count)
}

// .eve_public.app.platform.Machine.CPU cpu = 6;
inline bool Machine::has_cpu() const {
  return this != internal_default_instance() && cpu_ != NULL;
}
inline void Machine::clear_cpu() {
  if (GetArenaNoVirtual() == NULL && cpu_ != NULL) {
    delete cpu_;
  }
  cpu_ = NULL;
}
inline const ::eve_public::app::platform::Machine_CPU& Machine::_internal_cpu() const {
  return *cpu_;
}
inline const ::eve_public::app::platform::Machine_CPU& Machine::cpu() const {
  const ::eve_public::app::platform::Machine_CPU* p = cpu_;
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.cpu)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_public::app::platform::Machine_CPU*>(
      &::eve_public::app::platform::_Machine_CPU_default_instance_);
}
inline ::eve_public::app::platform::Machine_CPU* Machine::release_cpu() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.Machine.cpu)
  
  ::eve_public::app::platform::Machine_CPU* temp = cpu_;
  cpu_ = NULL;
  return temp;
}
inline ::eve_public::app::platform::Machine_CPU* Machine::mutable_cpu() {
  
  if (cpu_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_public::app::platform::Machine_CPU>(GetArenaNoVirtual());
    cpu_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.Machine.cpu)
  return cpu_;
}
inline void Machine::set_allocated_cpu(::eve_public::app::platform::Machine_CPU* cpu) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete cpu_;
  }
  if (cpu) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cpu = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cpu, submessage_arena);
    }
    
  } else {
    
  }
  cpu_ = cpu;
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.Machine.cpu)
}

// .eve_public.app.platform.Machine.VM vm = 7;
inline bool Machine::has_vm() const {
  return this != internal_default_instance() && vm_ != NULL;
}
inline void Machine::clear_vm() {
  if (GetArenaNoVirtual() == NULL && vm_ != NULL) {
    delete vm_;
  }
  vm_ = NULL;
}
inline const ::eve_public::app::platform::Machine_VM& Machine::_internal_vm() const {
  return *vm_;
}
inline const ::eve_public::app::platform::Machine_VM& Machine::vm() const {
  const ::eve_public::app::platform::Machine_VM* p = vm_;
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.vm)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_public::app::platform::Machine_VM*>(
      &::eve_public::app::platform::_Machine_VM_default_instance_);
}
inline ::eve_public::app::platform::Machine_VM* Machine::release_vm() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.Machine.vm)
  
  ::eve_public::app::platform::Machine_VM* temp = vm_;
  vm_ = NULL;
  return temp;
}
inline ::eve_public::app::platform::Machine_VM* Machine::mutable_vm() {
  
  if (vm_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_public::app::platform::Machine_VM>(GetArenaNoVirtual());
    vm_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.Machine.vm)
  return vm_;
}
inline void Machine::set_allocated_vm(::eve_public::app::platform::Machine_VM* vm) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete vm_;
  }
  if (vm) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      vm = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, vm, submessage_arena);
    }
    
  } else {
    
  }
  vm_ = vm;
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.Machine.vm)
}

// repeated .eve_public.app.platform.Machine.Monitor monitors = 8;
inline int Machine::monitors_size() const {
  return monitors_.size();
}
inline void Machine::clear_monitors() {
  monitors_.Clear();
}
inline ::eve_public::app::platform::Machine_Monitor* Machine::mutable_monitors(int index) {
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.Machine.monitors)
  return monitors_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::eve_public::app::platform::Machine_Monitor >*
Machine::mutable_monitors() {
  // @@protoc_insertion_point(field_mutable_list:eve_public.app.platform.Machine.monitors)
  return &monitors_;
}
inline const ::eve_public::app::platform::Machine_Monitor& Machine::monitors(int index) const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.monitors)
  return monitors_.Get(index);
}
inline ::eve_public::app::platform::Machine_Monitor* Machine::add_monitors() {
  // @@protoc_insertion_point(field_add:eve_public.app.platform.Machine.monitors)
  return monitors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::eve_public::app::platform::Machine_Monitor >&
Machine::monitors() const {
  // @@protoc_insertion_point(field_list:eve_public.app.platform.Machine.monitors)
  return monitors_;
}

// repeated .eve_public.app.platform.Machine.GPU gpus = 9;
inline int Machine::gpus_size() const {
  return gpus_.size();
}
inline void Machine::clear_gpus() {
  gpus_.Clear();
}
inline ::eve_public::app::platform::Machine_GPU* Machine::mutable_gpus(int index) {
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.Machine.gpus)
  return gpus_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::eve_public::app::platform::Machine_GPU >*
Machine::mutable_gpus() {
  // @@protoc_insertion_point(field_mutable_list:eve_public.app.platform.Machine.gpus)
  return &gpus_;
}
inline const ::eve_public::app::platform::Machine_GPU& Machine::gpus(int index) const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.gpus)
  return gpus_.Get(index);
}
inline ::eve_public::app::platform::Machine_GPU* Machine::add_gpus() {
  // @@protoc_insertion_point(field_add:eve_public.app.platform.Machine.gpus)
  return gpus_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::eve_public::app::platform::Machine_GPU >&
Machine::gpus() const {
  // @@protoc_insertion_point(field_list:eve_public.app.platform.Machine.gpus)
  return gpus_;
}

// repeated .eve_public.app.platform.Machine.NetworkAdapter network_adapters = 10;
inline int Machine::network_adapters_size() const {
  return network_adapters_.size();
}
inline void Machine::clear_network_adapters() {
  network_adapters_.Clear();
}
inline ::eve_public::app::platform::Machine_NetworkAdapter* Machine::mutable_network_adapters(int index) {
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.Machine.network_adapters)
  return network_adapters_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::eve_public::app::platform::Machine_NetworkAdapter >*
Machine::mutable_network_adapters() {
  // @@protoc_insertion_point(field_mutable_list:eve_public.app.platform.Machine.network_adapters)
  return &network_adapters_;
}
inline const ::eve_public::app::platform::Machine_NetworkAdapter& Machine::network_adapters(int index) const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.network_adapters)
  return network_adapters_.Get(index);
}
inline ::eve_public::app::platform::Machine_NetworkAdapter* Machine::add_network_adapters() {
  // @@protoc_insertion_point(field_add:eve_public.app.platform.Machine.network_adapters)
  return network_adapters_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::eve_public::app::platform::Machine_NetworkAdapter >&
Machine::network_adapters() const {
  // @@protoc_insertion_point(field_list:eve_public.app.platform.Machine.network_adapters)
  return network_adapters_;
}

// .eve_public.app.platform.Machine.BatteryDetection battery_detection = 11;
inline void Machine::clear_battery_detection() {
  battery_detection_ = 0;
}
inline ::eve_public::app::platform::Machine_BatteryDetection Machine::battery_detection() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.battery_detection)
  return static_cast< ::eve_public::app::platform::Machine_BatteryDetection >(battery_detection_);
}
inline void Machine::set_battery_detection(::eve_public::app::platform::Machine_BatteryDetection value) {
  
  battery_detection_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Machine.battery_detection)
}

// repeated .eve_public.app.platform.Machine.HardDrive hard_drives = 12;
inline int Machine::hard_drives_size() const {
  return hard_drives_.size();
}
inline void Machine::clear_hard_drives() {
  hard_drives_.Clear();
}
inline ::eve_public::app::platform::Machine_HardDrive* Machine::mutable_hard_drives(int index) {
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.Machine.hard_drives)
  return hard_drives_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::eve_public::app::platform::Machine_HardDrive >*
Machine::mutable_hard_drives() {
  // @@protoc_insertion_point(field_mutable_list:eve_public.app.platform.Machine.hard_drives)
  return &hard_drives_;
}
inline const ::eve_public::app::platform::Machine_HardDrive& Machine::hard_drives(int index) const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Machine.hard_drives)
  return hard_drives_.Get(index);
}
inline ::eve_public::app::platform::Machine_HardDrive* Machine::add_hard_drives() {
  // @@protoc_insertion_point(field_add:eve_public.app.platform.Machine.hard_drives)
  return hard_drives_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::eve_public::app::platform::Machine_HardDrive >&
Machine::hard_drives() const {
  // @@protoc_insertion_point(field_list:eve_public.app.platform.Machine.hard_drives)
  return hard_drives_;
}

// -------------------------------------------------------------------

// Process

// bool running_under_rosetta = 1;
inline void Process::clear_running_under_rosetta() {
  running_under_rosetta_ = false;
}
inline bool Process::running_under_rosetta() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Process.running_under_rosetta)
  return running_under_rosetta_;
}
inline void Process::set_running_under_rosetta(bool value) {
  
  running_under_rosetta_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Process.running_under_rosetta)
}

// .eve_public.app.platform.Bitness bitness = 2;
inline void Process::clear_bitness() {
  bitness_ = 0;
}
inline ::eve_public::app::platform::Bitness Process::bitness() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Process.bitness)
  return static_cast< ::eve_public::app::platform::Bitness >(bitness_);
}
inline void Process::set_bitness(::eve_public::app::platform::Bitness value) {
  
  bitness_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Process.bitness)
}

// -------------------------------------------------------------------

// Information

// .eve_public.app.platform.SemanticVersion version = 1;
inline bool Information::has_version() const {
  return this != internal_default_instance() && version_ != NULL;
}
inline void Information::clear_version() {
  if (GetArenaNoVirtual() == NULL && version_ != NULL) {
    delete version_;
  }
  version_ = NULL;
}
inline const ::eve_public::app::platform::SemanticVersion& Information::_internal_version() const {
  return *version_;
}
inline const ::eve_public::app::platform::SemanticVersion& Information::version() const {
  const ::eve_public::app::platform::SemanticVersion* p = version_;
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Information.version)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_public::app::platform::SemanticVersion*>(
      &::eve_public::app::platform::_SemanticVersion_default_instance_);
}
inline ::eve_public::app::platform::SemanticVersion* Information::release_version() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.Information.version)
  
  ::eve_public::app::platform::SemanticVersion* temp = version_;
  version_ = NULL;
  return temp;
}
inline ::eve_public::app::platform::SemanticVersion* Information::mutable_version() {
  
  if (version_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_public::app::platform::SemanticVersion>(GetArenaNoVirtual());
    version_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.Information.version)
  return version_;
}
inline void Information::set_allocated_version(::eve_public::app::platform::SemanticVersion* version) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete version_;
  }
  if (version) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      version = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, version, submessage_arena);
    }
    
  } else {
    
  }
  version_ = version;
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.Information.version)
}

// .google.protobuf.Timestamp timestamp = 2;
inline bool Information::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline const ::google::protobuf::Timestamp& Information::_internal_timestamp() const {
  return *timestamp_;
}
inline const ::google::protobuf::Timestamp& Information::timestamp() const {
  const ::google::protobuf::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Information.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* Information::release_timestamp() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.Information.timestamp)
  
  ::google::protobuf::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline ::google::protobuf::Timestamp* Information::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaNoVirtual());
    timestamp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.Information.timestamp)
  return timestamp_;
}
inline void Information::set_allocated_timestamp(::google::protobuf::Timestamp* timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.Information.timestamp)
}

// .eve_public.app.platform.Bitness process_bitness = 3 [deprecated = true];
inline void Information::clear_process_bitness() {
  process_bitness_ = 0;
}
inline ::eve_public::app::platform::Bitness Information::process_bitness() const {
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Information.process_bitness)
  return static_cast< ::eve_public::app::platform::Bitness >(process_bitness_);
}
inline void Information::set_process_bitness(::eve_public::app::platform::Bitness value) {
  
  process_bitness_ = value;
  // @@protoc_insertion_point(field_set:eve_public.app.platform.Information.process_bitness)
}

// .eve_public.app.platform.OS os = 4;
inline bool Information::has_os() const {
  return this != internal_default_instance() && os_ != NULL;
}
inline void Information::clear_os() {
  if (GetArenaNoVirtual() == NULL && os_ != NULL) {
    delete os_;
  }
  os_ = NULL;
}
inline const ::eve_public::app::platform::OS& Information::_internal_os() const {
  return *os_;
}
inline const ::eve_public::app::platform::OS& Information::os() const {
  const ::eve_public::app::platform::OS* p = os_;
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Information.os)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_public::app::platform::OS*>(
      &::eve_public::app::platform::_OS_default_instance_);
}
inline ::eve_public::app::platform::OS* Information::release_os() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.Information.os)
  
  ::eve_public::app::platform::OS* temp = os_;
  os_ = NULL;
  return temp;
}
inline ::eve_public::app::platform::OS* Information::mutable_os() {
  
  if (os_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_public::app::platform::OS>(GetArenaNoVirtual());
    os_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.Information.os)
  return os_;
}
inline void Information::set_allocated_os(::eve_public::app::platform::OS* os) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete os_;
  }
  if (os) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      os = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, os, submessage_arena);
    }
    
  } else {
    
  }
  os_ = os;
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.Information.os)
}

// .eve_public.app.platform.Machine machine = 5;
inline bool Information::has_machine() const {
  return this != internal_default_instance() && machine_ != NULL;
}
inline void Information::clear_machine() {
  if (GetArenaNoVirtual() == NULL && machine_ != NULL) {
    delete machine_;
  }
  machine_ = NULL;
}
inline const ::eve_public::app::platform::Machine& Information::_internal_machine() const {
  return *machine_;
}
inline const ::eve_public::app::platform::Machine& Information::machine() const {
  const ::eve_public::app::platform::Machine* p = machine_;
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Information.machine)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_public::app::platform::Machine*>(
      &::eve_public::app::platform::_Machine_default_instance_);
}
inline ::eve_public::app::platform::Machine* Information::release_machine() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.Information.machine)
  
  ::eve_public::app::platform::Machine* temp = machine_;
  machine_ = NULL;
  return temp;
}
inline ::eve_public::app::platform::Machine* Information::mutable_machine() {
  
  if (machine_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_public::app::platform::Machine>(GetArenaNoVirtual());
    machine_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.Information.machine)
  return machine_;
}
inline void Information::set_allocated_machine(::eve_public::app::platform::Machine* machine) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete machine_;
  }
  if (machine) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      machine = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, machine, submessage_arena);
    }
    
  } else {
    
  }
  machine_ = machine;
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.Information.machine)
}

// .eve_public.app.platform.Process process = 6;
inline bool Information::has_process() const {
  return this != internal_default_instance() && process_ != NULL;
}
inline void Information::clear_process() {
  if (GetArenaNoVirtual() == NULL && process_ != NULL) {
    delete process_;
  }
  process_ = NULL;
}
inline const ::eve_public::app::platform::Process& Information::_internal_process() const {
  return *process_;
}
inline const ::eve_public::app::platform::Process& Information::process() const {
  const ::eve_public::app::platform::Process* p = process_;
  // @@protoc_insertion_point(field_get:eve_public.app.platform.Information.process)
  return p != NULL ? *p : *reinterpret_cast<const ::eve_public::app::platform::Process*>(
      &::eve_public::app::platform::_Process_default_instance_);
}
inline ::eve_public::app::platform::Process* Information::release_process() {
  // @@protoc_insertion_point(field_release:eve_public.app.platform.Information.process)
  
  ::eve_public::app::platform::Process* temp = process_;
  process_ = NULL;
  return temp;
}
inline ::eve_public::app::platform::Process* Information::mutable_process() {
  
  if (process_ == NULL) {
    auto* p = CreateMaybeMessage<::eve_public::app::platform::Process>(GetArenaNoVirtual());
    process_ = p;
  }
  // @@protoc_insertion_point(field_mutable:eve_public.app.platform.Information.process)
  return process_;
}
inline void Information::set_allocated_process(::eve_public::app::platform::Process* process) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete process_;
  }
  if (process) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      process = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, process, submessage_arena);
    }
    
  } else {
    
  }
  process_ = process;
  // @@protoc_insertion_point(field_set_allocated:eve_public.app.platform.Information.process)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace platform
}  // namespace app
}  // namespace eve_public

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::eve_public::app::platform::OS_StreamingService_Provider> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eve_public::app::platform::OS_StreamingService_Provider>() {
  return ::eve_public::app::platform::OS_StreamingService_Provider_descriptor();
}
template <> struct is_proto_enum< ::eve_public::app::platform::OS_Kind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eve_public::app::platform::OS_Kind>() {
  return ::eve_public::app::platform::OS_Kind_descriptor();
}
template <> struct is_proto_enum< ::eve_public::app::platform::Machine_CPU_Architecture> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eve_public::app::platform::Machine_CPU_Architecture>() {
  return ::eve_public::app::platform::Machine_CPU_Architecture_descriptor();
}
template <> struct is_proto_enum< ::eve_public::app::platform::Machine_HardDrive_DriveType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eve_public::app::platform::Machine_HardDrive_DriveType>() {
  return ::eve_public::app::platform::Machine_HardDrive_DriveType_descriptor();
}
template <> struct is_proto_enum< ::eve_public::app::platform::Machine_BatteryDetection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eve_public::app::platform::Machine_BatteryDetection>() {
  return ::eve_public::app::platform::Machine_BatteryDetection_descriptor();
}
template <> struct is_proto_enum< ::eve_public::app::platform::Bitness> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::eve_public::app::platform::Bitness>() {
  return ::eve_public::app::platform::Bitness_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_eve_5fpublic_2fapp_2fplatform_2eproto
